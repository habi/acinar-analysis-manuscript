<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="David Haberthür" />
  <meta name="author" content="Eveline Yao" />
  <meta name="author" content="Sébastien F. Barré" />
  <meta name="author" content="Tiziana P. Cremona" />
  <meta name="author" content="Stefan A. Tschanz" />
  <meta name="author" content="Johannes C. Schittny" />
  <meta name="dcterms.date" content="2020-12-01" />
  <meta name="keywords" content="lung, acini, tomography" />
  <title>Pulmonary acini exhibit complex changes during postnatal rat lung development</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <!--
  Manubot generated metadata rendered from header-includes-template.html.
  Suggest improvements at https://github.com/manubot/manubot/blob/master/manubot/process/header-includes-template.html
  -->
  <meta name="dc.format" content="text/html" />
  <meta name="dc.title" content="Pulmonary acini exhibit complex changes during postnatal rat lung development" />
  <meta name="citation_title" content="Pulmonary acini exhibit complex changes during postnatal rat lung development" />
  <meta property="og:title" content="Pulmonary acini exhibit complex changes during postnatal rat lung development" />
  <meta property="twitter:title" content="Pulmonary acini exhibit complex changes during postnatal rat lung development" />
  <meta name="dc.date" content="2020-12-01" />
  <meta name="citation_publication_date" content="2020-12-01" />
  <meta name="dc.language" content="en-US" />
  <meta name="citation_language" content="en-US" />
  <meta name="dc.relation.ispartof" content="Manubot" />
  <meta name="dc.publisher" content="Manubot" />
  <meta name="citation_journal_title" content="Manubot" />
  <meta name="citation_technical_report_institution" content="Manubot" />
  <meta name="citation_author" content="David Haberthür" />
  <meta name="citation_author_institution" content="Institute of Anatomy, University of Bern, Switzerland" />
  <meta name="citation_author_orcid" content="0000-0003-3388-9187" />
  <meta name="twitter:creator" content="@habi" />
  <meta name="citation_author" content="Eveline Yao" />
  <meta name="citation_author_institution" content="Institute of Anatomy, University of Bern, Switzerland" />
  <meta name="citation_author" content="Sébastien F. Barré" />
  <meta name="citation_author_institution" content="Institute of Anatomy, University of Bern, Switzerland" />
  <meta name="citation_author" content="Tiziana P. Cremona" />
  <meta name="citation_author_institution" content="Institute of Anatomy, University of Bern, Switzerland" />
  <meta name="citation_author_orcid" content="0000-0003-0061-9578" />
  <meta name="citation_author" content="Stefan A. Tschanz" />
  <meta name="citation_author_institution" content="Institute of Anatomy, University of Bern, Switzerland" />
  <meta name="citation_author_orcid" content="0000-0003-3880-4437" />
  <meta name="citation_author" content="Johannes C. Schittny" />
  <meta name="citation_author_institution" content="Institute of Anatomy, University of Bern, Switzerland" />
  <meta name="citation_author_orcid" content="0000-0003-4025-3961" />
  <link rel="canonical" href="https://habi.github.io/acinar-analysis-manuscript/" />
  <meta property="og:url" content="https://habi.github.io/acinar-analysis-manuscript/" />
  <meta property="twitter:url" content="https://habi.github.io/acinar-analysis-manuscript/" />
  <meta name="citation_fulltext_html_url" content="https://habi.github.io/acinar-analysis-manuscript/" />
  <meta name="citation_pdf_url" content="https://habi.github.io/acinar-analysis-manuscript/manuscript.pdf" />
  <link rel="alternate" type="application/pdf" href="https://habi.github.io/acinar-analysis-manuscript/manuscript.pdf" />
  <link rel="alternate" type="text/html" href="https://habi.github.io/acinar-analysis-manuscript/v/74e027d6ca9001c0312a718ef154342f00c12b5f/" />
  <meta name="manubot_html_url_versioned" content="https://habi.github.io/acinar-analysis-manuscript/v/74e027d6ca9001c0312a718ef154342f00c12b5f/" />
  <meta name="manubot_pdf_url_versioned" content="https://habi.github.io/acinar-analysis-manuscript/v/74e027d6ca9001c0312a718ef154342f00c12b5f/manuscript.pdf" />
  <meta property="og:type" content="article" />
  <meta property="twitter:card" content="summary_large_image" />
  <link rel="icon" type="image/png" sizes="192x192" href="https://manubot.org/favicon-192x192.png" />
  <link rel="mask-icon" href="https://manubot.org/safari-pinned-tab.svg" color="#ad1457" />
  <meta name="theme-color" content="#ad1457" />
  <!-- end Manubot generated metadata -->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Pulmonary acini exhibit complex changes during postnatal rat lung development</h1>
</header>
<p><small><em>
This manuscript
(<a href="https://habi.github.io/acinar-analysis-manuscript/v/74e027d6ca9001c0312a718ef154342f00c12b5f/">permalink</a>)
was automatically generated
from <a href="https://github.com/habi/acinar-analysis-manuscript/tree/74e027d6ca9001c0312a718ef154342f00c12b5f">habi/acinar-analysis-manuscript@74e027d</a>
on December 1, 2020.
</em></small></p>
<h2 id="authors">Authors</h2>
<ul>
<li><p><strong>David Haberthür</strong><br>
<img src="images/orcid.svg" class="inline_icon" alt="ORCID icon" />
<a href="https://orcid.org/0000-0003-3388-9187">0000-0003-3388-9187</a>
· <img src="images/github.svg" class="inline_icon" alt="GitHub icon" />
<a href="https://github.com/habi">habi</a>
· <img src="images/twitter.svg" class="inline_icon" alt="Twitter icon" />
<a href="https://twitter.com/habi">habi</a><br>
<small>
Institute of Anatomy, University of Bern, Switzerland
· Funded by Swiss National Science Foundation (Schweizerische Nationalfonds) http://p3.snf.ch/project-153468; Swiss National Science Foundation (Schweizerische Nationalfonds) http://p3.snf.ch/project-175953
</small></p></li>
<li><p><strong>Eveline Yao</strong><br><br>
<small>
Institute of Anatomy, University of Bern, Switzerland
</small></p></li>
<li><p><strong>Sébastien F. Barré</strong><br><br>
<small>
Institute of Anatomy, University of Bern, Switzerland
· Funded by Swiss National Science Foundation (Schweizerische Nationalfonds) 153468; Swiss National Science Foundation (Schweizerische Nationalfonds) 175953
</small></p></li>
<li><p><strong>Tiziana P. Cremona</strong><br>
<img src="images/orcid.svg" class="inline_icon" alt="ORCID icon" />
<a href="https://orcid.org/0000-0003-0061-9578">0000-0003-0061-9578</a><br>
<small>
Institute of Anatomy, University of Bern, Switzerland
· Funded by Swiss National Science Foundation (Schweizerische Nationalfonds) 153468; Swiss National Science Foundation (Schweizerische Nationalfonds) 175953
</small></p></li>
<li><p><strong>Stefan A. Tschanz</strong><br>
<img src="images/orcid.svg" class="inline_icon" alt="ORCID icon" />
<a href="https://orcid.org/0000-0003-3880-4437">0000-0003-3880-4437</a><br>
<small>
Institute of Anatomy, University of Bern, Switzerland
</small></p></li>
<li><p><strong>Johannes C. Schittny</strong><br>
<img src="images/orcid.svg" class="inline_icon" alt="ORCID icon" />
<a href="https://orcid.org/0000-0003-4025-3961">0000-0003-4025-3961</a><br>
<small>
Institute of Anatomy, University of Bern, Switzerland
· Funded by Swiss National Science Foundation (Schweizerische Nationalfonds) 153468; Swiss National Science Foundation (Schweizerische Nationalfonds) 175953
</small></p></li>
</ul>
<h2 class="page_break_before" id="abstract">Abstract</h2>
<p>Pulmonary acini represent the functional gas-exchanging units of the lung.
Due to technical limitations, it is not possible to identify individual acini on microscopic lung sections.
We imaged instillation-fixed rat lungs at postnatal days P4, P10, P21, and P60 to overcome these limitations.
Right lower lobes of these lungs were imaged at the TOMCAT beamline of the Swiss Light Source synchrotron facility at a voxel size of 1.48 μm.
Individual acini (N=268) were segmented from the 3D data by closing the airways ways at the transition point from conducting to gas exchanging airways.
Acinar development was followed by estimating the individual acinar volume, complexity, and number of alveoli.
The mean volume of the acini increases 23 times during the observed timeframe.
The coefficients of variation dropped from 1.26 to 0.49 and the difference between the mean volumes of the fraction of the 20 % smallest to the 20 % largest acini decreased from a factor of 27.26 (day 4) to a factor of 4.07 (day 60), i.e. shows a smaller dispersion at later time points.
This indicates that the acinar volumes show a very large variation at early timepoints and homogenize during maturation of the lung.
Our approach is well suited to follow acinar development and to acquire stereologically correct data in a time-efficient manner.
We found that the newly formed acini show a large size distribution which is reduced by a factor of 7 until adulthood.
Most likely this leads to a more homogeneous ventilation in the lung.</p>
<h2 id="introduction">Introduction</h2>
<h3 id="lung-development">Lung development</h3>
<p>Lung development starts with the formation of the two lung buds. During the embryonic stage (prenatal
days E11-E13 in rats) the major airways and the pleura are formed. During the pseudoglandular stage
(E13-E18.5) most of the remaining airway generations are formed by branching morphogenesis. Few
additional branches are added during the canalicular (E18.5 - E20) and maybe the saccular stage (E20
to postnatal day P4). Epithelial differentiation becomes morphologically visible during the canalicular
stage. Together with angiogenetic activation of the capillaries, this process leads to the first functional
air-blood barriers in the lung.
The saccular stage represents an intermediate stage where branching morphogenesis ceases and the
developmental program switches to the phase of alveolarization. During alveolarization, 90 % of the adult
gas-exchange area is formed by the lifting oﬀ of new septa from the existing gas-exchange surface (1; 2; 3).
Alveolarization itself is divided into two distinct phases, the so-called classical (P4-P21) and continued
alveolarization (P14 to approximately P60).
During classical alveolarization, new septa are formed starting from preexisting immature septa which
contain a double-layered capillary network. During alveolarization, the structure of the alveolar septa
is changed to increase the efficiency of the lung. It includes the transformation of the double-layered
capillary network into a single-layered one. As a consequence, angiogenesis is necessary at the basis of the
newly forming septa. To distinguish these modes of the formation of new alveolar septa and to specify
that alveolarization continues after classical alveolarization ceased, the second phase of alveolarization
is called continued alveolarization. Here, the timing of lung development is given for rats while the same
stages and developmental mechanisms are observed in every placentalian species studied so far, including
humans. However, the timing of lung development and especially the time point of birth relative to lung
development is adapted in each species (3; 4; 5).</p>
<h3 id="the-functional-lung-units">The functional lung units</h3>
<p>Pulmonary acini represent the gas-exchanging units of the bronchial tree and are defined as the airways
distal of the terminal bronchioles (6). In humans, the acini contain approximately four generations
of respiratory bronchioles before reaching the alveolar ducts. The alveolar ducts start at the so-called
bronchioalveolar duct junction (BADJ) where the lining of the inner airway surface abruptly changes
from the cuboidal epithelium of the bronchioles into type 1 and type 2 alveolar epithelium which covers
the alveoli. The small tree of airways distal of the BADJ is called a ventilatory unit (7). Since murine
lungs do not possess respiratory bronchioles, the murine acini consist of one single ventilatory unit (7).
In this study we used rat lungs; hence we exclusively speak of acini. To translate our results to humans,
monkeys, or dogs, one would have to compare a rat acinus to a single ventilatory unit in these species.
Developmentally, the BADJ is of particular interest. The junction is formed during the canalicular stage
when the epithelia are differentiating. Ciliated epithelia containing goblet or club cells form proximal
and type I and II alveolar epithelia form distal of the BADJ. The BADJ is home to various stem cells (7).
The generation of the airway in which an individual murine acinus starts is defined during the canalicular
stage and remains constant once it is formed. As a consequence, the number of formed acini also remains
constant during the phase of alveolarization and thereafter (8; 9). The latter was somehow surprising
because the total lung volume increases by roughly a factor of 10 during alveolarization (10). Therefore,
the mean volume of the acini has to increase by approximately the same factor. Since the acinus volume
can easily be estimated with the Cavalieri principle (11), we can test if and how the acinus volume
increases during lung development.</p>
<p>However, besides the global numbers little is known about the range of the volume of individual acini
throughout lung development. The latter represents a physiological significant value, because it has been
shown by pulmonary particle deposition (12; 13; 10) and by computational ﬂuid dynamics simulations
of airﬂow (14; 15; 16) that the acinar architecture is important for ventilation and particle deposition.
However, due to the lack of measured data, these simulations are based on acinar models. Therefore, the
question of how well these models represent lung physiology remains open until the necessary data and
physiologically correct models are available. To contribute to the validation of the computational ﬂuid
dynamics simulations, we determined the volume and number of alveoli in individual acini throughout
rat lung development.</p>
<h3 id="acinus-detection-and-delineation">Acinus detection and delineation</h3>
<p>To detect and delineate individual acini, three-dimensional information is needed. On single two-dimensional
(histological) sections it is not possible to unambiguously detect which parts of the airways
and alveoli in the lung parenchyma are connected three-dimensionally. Historically, single or very few
acini were delineated and extracted from manually traced serial sections (17; 18) or sectioned silicone
casts (19), both with considerable manual work. Non-destructive three-dimensional imaging is best
suited to acquire data sets that can be used to easily detect, delineate and study large amounts of single
acini. This has been shown by Vasilescu et al. (20). In their study, they reconstructed 22 mouse acini
from tomographic data sets of four 12 week old mice (at least postnatal day 84, fully developed lungs)
and compared those with scanning electron microscope images of acinar silicone rubber casts. Similarly,
Kizhakke Puliyakote et al. (21) analyzed the volume of 32 mouse acini from six animals, as well as the
branching pattern of their internal airways. All prior work known to us has analyzed considerably fewer
acini than the 268 acini presented in this manuscript and - due to the study design - focuses only on one
time point, where the lungs of the animals are already fully developed while we are wable to analyze the
acini over the course of postnatal lung development.</p>
<p>The hereby presented method is well adapted to thoroughly analyze large amounts of acini in a time-efficient manner.
The largest part of the work is spent on the detailed stereological analysis of the
extracted acini. The method makes it possible to provide data spanning relevant parts of the lung development in animals.
As confirmed by Vasilescu et al. (22), stereologically analyzing microtomographic
data provides quantitative information on internal structures of the lung while preserving the samples
for further studies.</p>
<h2 id="materials-methods">Materials &amp; Methods</h2>
<h3 id="rat-lung-samples">Rat lung samples</h3>
<p>In the present study, a superset of the animals described by Haberthür et al. (23) were used. Tschanz et
al. (10) described a biphasic formation of new alveoli on the same set of animals. The stereological analysis
presented here represents a part of the 3R-initiative (replacement, reduction, and refinement) (24) for
the ethical use and the reduction of the number of animals sacrificed for science.</p>
<p>Brieﬂy, we extracted the lungs of Sprague-Dawley rats after having deeply anesthetized them with a
mixture of medetomidine, midazolam, and fentanyl (25). The rats were euthanized by exsanguination
during the removal of the lung. The lungs were fixed with 2.5 % glutaraldehyde by intratracheal instillation and kept under constant pressure (20 cm H2 O) during fixation to prevent recoiling of the tissue.
The samples were prepared for tomographic imaging by post-fixation with 1 % osmium tetroxide and
staining with 4 % uranyl acetate, as well as by dehydration in a graded series of ethanol and embedding
in paraﬃn. In total we assessed 12 animals, on postnatal days P4, P10, P21, and P60 (N=3 per day.
From now on, we will omit the postnatal prefix and only mention the day.).</p>
<p>The animals were housed in the central animal facility of the University of Bern. They received food and
water ad libitum at a 12/12 hours day/night cycle. The experiments themselves, as well as the handling
of the animals before and during the experiments, were approved and supervised by the Federal Food
Safety and Veterinary Oﬃce of Switzerland and the Department of Agriculture and Nature of the Kanton
of Bern in Switzerland.</p>
<h3 id="tomographic-imaging">Tomographic imaging</h3>
<p>Tomographic imaging was performed at the TOMCAT beamline (26; 27) of the Swiss Light Source
at the Paul Scherrer Institute in Villigen, Switzerland. The samples were scanned at an X-ray energy
of 20.0 keV. After penetrating the sample, the X-rays were converted into visible light by either a
20-μm-thick LuAG:Ce or 18-μm-thick YAG:Ce scintillator screen (both from Crytur, Turnov, Czech
Republic), depending on the date of experiments. The resulting visible light was magnified using a 10times magnifying, diﬀraction-limited microscope lens and recorded with a 2048×2048 pixel CCD camera
(pco.2000, PCO, Kelheim, Germany) with 14 bits dynamic range operated in 2 by 2 binning mode. As a
result, in a single field of view, we were able to image a sample volume of a cube of 1.5 mm side length
with a voxel side length of 1.48 μm, with the exposure time of the single projections varying between
160 and 200 ms.
Since our samples were substantially larger than the field of view of the detector, we applied the socalled wide-field scanning method (28) to increase the field of view horizontally. For each sub-scan, we
recorded 3578 projections and laterally stitched them so that their combined field of view covered the
whole sample width. Additionally, two or three such wide-field scans were stacked vertically to match
the sample height.
The resulting data sets for each of the lung samples covered a field of view of a cube with approximately
4.5 mm side length which corresponds to an image stack with approximately 3000×3000×3000 pixels at
1.48 μm side length each. The mean size of the tomographic reconstructions, corresponding to the raw
data of each of the 42 analyzed tomographic scans is 8 GB, totaling to 336 GB.</p>
<h3 id="extraction-of-acini">Extraction of acini</h3>
<p>For the present manuscript, we extracted single acini from three-dimensional data, acquired without
destroying the samples. Details of this semi-automatic extraction of the rat acini are described by Haberthür et al. (23). We applied this protocol to extract 701 randomly selected acini throughout lung
development, at postnatal days 4, 10, 21 and 60. Individual acini were extracted from the tomographic
data with a custom image processing network established in MeVisLab (version 2.1, 2010-07-26 release, MeVis Medical Solutions and Fraunhofer MEVIS-Institute for Medical Image Computing, Bremen,
Germany).</p>
<p>This extraction was performed by segmenting the acinus volume with a gray-level threshold-based region
growing algorithm using manually placed seed points. To isolate individual acini in the data set we placed
disk-shaped segmentation stoppers at the acinus entrances. Each individual acinus was then exported as
a single DICOM file for portability. For each acinus, its exported DICOM file contained the segmented
acinus overlaid with the original background for further analysis. Example images from the DICOM files
are shown in the bottom row of Fig 1.</p>
<h3 id="stereological-analysis-of-alveolar-characteristics">Stereological analysis of alveolar characteristics</h3>
<p>The stereological estimation of the alveolar number was performed according to the standards for quantitative assessment of lung structure from the American Thoracic Society (29) to guarantee accurate
and unbiased results. To perform the stereological analysis, each DICOM file from the isolated acini was
sampled into a systematic random set of single images using a MATLAB script (30).
The stereological assessment was performed with the STEPanizer (31), an easy-to-use software tool for
the stereological assessment of digital images. Details of the stereological assessment have previously
been described (32). Brieﬂy, we counted the appearance or disappearance of alveolar wall interruptions.
Under the assumption that these only occur in the region of the alveolar mouth opening and correspond
to alveolar entrance rings (33) we counted said interruptions on paired images spanning the whole acinus
volume. By using the disector method (34) we were thus able to estimate the number of alveoli in 268 of
the 701 exported acini. The acini we analyzed were subsampled from the full data by systematic uniform
random sampling (35). Brieﬂy, a defined fraction of the acini of one animal were analyzed, e.g. one third.
During segmentation, the acini were numbered. Based on these numbers every third acinus was selected,
randomly starting with the first, second, or third one.</p>
<p>Previously, we have shown that the stereological assessment of the acinar volume (according to the
Cavalieri principle (36)) gives comparable results to an automated volume extraction by counting the
segmented pixels in the tomographic data sets (32). Due to variations in the gray value, the automatic
segmentation underestimates the volume of the single acini. The best-suited approach to obtain unbiased
results is to asses the volume manually according to the Cavalieri principle, which is what we did for the
268 acini presented in this manuscript. The sets of JPG slices and the raw results from the stereological
analysis with the STEPanizer are available on request.</p>
<h3 id="data-analysis-and-display">Data analysis and display</h3>
<p>All the stereologically assessed data was processed in a Jupyter (37) notebook, producing all the results,
including the statistical data and plots shown below. The notebook with all its history is freely available on
GitHub (38). The performed calculations are described in detail in section 3. In the plots, semitransparent
circles mark the single observations. The box shows the 25-75 % quartiles range of the data. The whiskers
extend to the rest of the distribution. Outliers are determined as a function of the inter-quartile range and
are shown outside the whiskers. Numerical values in the text are given as averages±standard deviation.
P-values in the text and figure legends are given as precise numbers, as suggested by Amhrein et al. (39).
Usually, we performed a Shapiro-Wilk test for normality (40) to test whether we can use an U-test
for assessing the differences, namely a two-sided Mann-Whitney rank test (41). This rank test was
used to assess the differences between the possible combinations. An additional Kruskal-Wallis H-test
for independent samples (42) was used to test for sample independence. The statistical analysis was
performed in the aforementioned notebook by using the statistical functions of the Scientific Computing
Tools for Python (43) or GraphPad Prism 7.01 (GraphPad Software, San Diego, CA, USA).</p>
<h2 id="results">Results</h2>
<p>The number of alveoli per acinus was assessed for 268 individual acini throughout postnatal lung development at days 4, 10, 21 and 60.
For day 4, we analyzed 125 acini, for day 10 we analyzed 58 acini, for
day 21 we analyzed 42 acini, and for day 60 we analyzed 43 acini.
To get started, we show an overview of our process in figure ??. Panels A-D show a representative light
microscopy image for each assessed time point. Panels E-H of figure ?? each correspond to one slice of the
tomographic data sets acquired at TOMCAT. Panels I-L of figure ?? show the middle slice of the datasets
used for the stereological analysis of the extracted acini. The acinus is shown in light gray as an overlay
over the tomographic data.</p>
<div id="fig:02" class="fignos">
<figure>
<img src="images/fig02.png" alt="" /><figcaption><span>Figure 1:</span> Example images for each of the assessed time points.
A-D: Representative light microscopy images.
E-H: One slice of the tomographic data sets.
I-L: Middle slice of one of the extracted acini.
The extracted acinus is overlaid on the tomographic dataset.
Panels J and K also show the segmentation stopper at the left border of the image.
The shown images correspond to the middle slice of the full data sets used for the stereological analysis.
The scale bar was burnt in during preparation of the image stacks and is 100 μm long.
Panels A, E &amp; I: Day 4. Panels B, F &amp; J: Day 10. Panels C, G &amp; K: Day 21. Panels D, H &amp; L: Day 60.</figcaption>
</figure>
</div>
<h3 id="alveoli-per-acinus">Alveoli per acinus</h3>
<p>The average entrance ring count, which corresponds to the number of alveoli per acinus for the 125 acini
at day 4 is 48±41 alveoli. For the 58 acini at day 10 it is 89±84 alveoli, for the 42 acini at day 21 it is
233±164 alveoli. At day 60 we assessed 43 acini in total, on average they have 702±219 alveoli.</p>
<p>The values for the single animal are given in table <a href="#tbl:counts">1</a> and plotted in figure <a href="#fig:02">2</a>.</p>
<p>The alveolar number shows highly significant differences (Šidák-corrected p-value &lt; 0.00167 (44)) between all possible combination of days.
All possible combinations of entrance ring counts per day are significantly different (all p-values are better than p=1.9e-5, which is the p-value of the difference between days 4 and 10). The entrance ring counts for all animals are independent (p=1.6e-34).</p>
<div id="tbl:counts" class="tablenos">
<table>
<caption><span>Table 1:</span> Detailed alveolar numbers for each animal. </caption>
<thead>
<tr class="header">
<th>Animal</th>
<th>Assessed acini</th>
<th>Average counts</th>
<th>STD</th>
<th>Minimum</th>
<th>Maximum</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>04A</td>
<td>51</td>
<td>26.73</td>
<td>23.56</td>
<td>4</td>
<td>111</td>
</tr>
<tr class="even">
<td>04B</td>
<td>23</td>
<td>65.04</td>
<td>43.85</td>
<td>15</td>
<td>171</td>
</tr>
<tr class="odd">
<td>04C</td>
<td>51</td>
<td>60.51</td>
<td>45.42</td>
<td>10</td>
<td>249</td>
</tr>
<tr class="even">
<td>10A</td>
<td>27</td>
<td>77.85</td>
<td>56.31</td>
<td>18</td>
<td>245</td>
</tr>
<tr class="odd">
<td>10B</td>
<td>14</td>
<td>84.57</td>
<td>65.75</td>
<td>23</td>
<td>199</td>
</tr>
<tr class="even">
<td>10C</td>
<td>17</td>
<td>108.76</td>
<td>125.45</td>
<td>15</td>
<td>505</td>
</tr>
<tr class="odd">
<td>21B</td>
<td>14</td>
<td>208.14</td>
<td>197.71</td>
<td>35</td>
<td>781</td>
</tr>
<tr class="even">
<td>21D</td>
<td>17</td>
<td>196.00</td>
<td>128.56</td>
<td>50</td>
<td>493</td>
</tr>
<tr class="odd">
<td>21E</td>
<td>11</td>
<td>323.09</td>
<td>145.94</td>
<td>108</td>
<td>572</td>
</tr>
<tr class="even">
<td>60B</td>
<td>24</td>
<td>701.75</td>
<td>230.95</td>
<td>322</td>
<td>1296</td>
</tr>
<tr class="odd">
<td>60D</td>
<td>10</td>
<td>668.30</td>
<td>121.67</td>
<td>444</td>
<td>810</td>
</tr>
<tr class="even">
<td>60E</td>
<td>9</td>
<td>739.11</td>
<td>281.22</td>
<td>272</td>
<td>1204</td>
</tr>
</tbody>
</table>
</div>
<div id="fig:02" class="fignos">
<figure>
<img src="images/fig02.png" alt="" /><figcaption><span>Figure 2:</span> Distribution of the number of alveoli per acinus (entrance ring count per acinus) for each animal.
Left: linear scale, right: logarithmic scale.
The entrance ring counts per day are all significantly different (all p-values better than 1.9e-5, which is the one between days 4 and 10).</figcaption>
</figure>
</div>
<h3 id="acinus-volume">Acinus volume</h3>
<p>The stereological assessment resulted in a mean acinar volume of 0.03±0.04 mm<sup>3</sup> for the 125 acini at
day 4. For the 58 acini at day 10 we get a volume of 0.04±0.05 mm<sup>3</sup>. For the 42 acini at day 21 a volume
of 0.10±0.09 mm<sup>3</sup> and for the 43 acini at day 60 a volume of 0.74±0.37 mm<sup>3</sup>.</p>
<p>The values for the single animals are shown in table <a href="#tbl:volumes">2</a> and displayed in figure ??. The mean volume of the
20 % smallest acini to the 20 % largest acini at day 4 increases 27.47 times (from 0.0035 μl to 0.095 μl,
N=25). At day 10, this increase is 15.28 times (from 0.0071 μl to 0.11 μl, N=12). At day 21, this increase
is 14.42 times (from 0.018 μl to 0.26 μl, N=8). At day 60, we saw an increase of 3.94 times (from 0.33 μl
to 1.3 μl, N=9).</p>
<div id="tbl:volumes" class="tablenos">
<table>
<caption><span>Table 2:</span> Detailed volume data (in mm<sup>3</sup>) for each animal. </caption>
<thead>
<tr class="header">
<th>Animal</th>
<th>Assessed acini</th>
<th>Average [mm^3]</th>
<th>STD [mm^3]</th>
<th>Minimum [mm^3]</th>
<th>Maximum [mm^3]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>04A</td>
<td>51</td>
<td>0.009</td>
<td>0.008</td>
<td>0.002</td>
<td>0.035</td>
</tr>
<tr class="even">
<td>04B</td>
<td>23</td>
<td>0.058</td>
<td>0.053</td>
<td>0.008</td>
<td>0.194</td>
</tr>
<tr class="odd">
<td>04C</td>
<td>51</td>
<td>0.044</td>
<td>0.044</td>
<td>0.006</td>
<td>0.275</td>
</tr>
<tr class="even">
<td>10A</td>
<td>27</td>
<td>0.033</td>
<td>0.026</td>
<td>0.004</td>
<td>0.108</td>
</tr>
<tr class="odd">
<td>10B</td>
<td>14</td>
<td>0.033</td>
<td>0.030</td>
<td>0.004</td>
<td>0.096</td>
</tr>
<tr class="even">
<td>10C</td>
<td>17</td>
<td>0.057</td>
<td>0.084</td>
<td>0.002</td>
<td>0.333</td>
</tr>
<tr class="odd">
<td>21B</td>
<td>14</td>
<td>0.087</td>
<td>0.086</td>
<td>0.011</td>
<td>0.322</td>
</tr>
<tr class="even">
<td>21D</td>
<td>17</td>
<td>0.109</td>
<td>0.112</td>
<td>0.014</td>
<td>0.380</td>
</tr>
<tr class="odd">
<td>21E</td>
<td>11</td>
<td>0.118</td>
<td>0.072</td>
<td>0.025</td>
<td>0.238</td>
</tr>
<tr class="even">
<td>60B</td>
<td>24</td>
<td>0.588</td>
<td>0.223</td>
<td>0.226</td>
<td>1.104</td>
</tr>
<tr class="odd">
<td>60D</td>
<td>10</td>
<td>0.888</td>
<td>0.350</td>
<td>0.364</td>
<td>1.576</td>
</tr>
<tr class="even">
<td>60E</td>
<td>9</td>
<td>0.977</td>
<td>0.526</td>
<td>0.186</td>
<td>1.875</td>
</tr>
</tbody>
</table>
</div>
<div id="fig:03" class="fignos">
<figure>
<img src="images/fig03.png" alt="" /><figcaption><span>Figure 3:</span> Distribution of the acinar volumes for each animal.
Left: linear scale, right: logarithmic scale.
The acinar volumes are all significantly different (all p-values better than 4.5e-6, which is the one between days 10 and 21) for each combination of days except between days 4 and 10 (p=0.08).</figcaption>
</figure>
</div>
<p>The acinar volumes show highly significant differences between all possible combinations of days except
between days 4 and 10 (p=0.08). All other p-values are better than p=4.5e-6, which is the p-value for
the difference between days 10 and 21. The statistical analysis is equal to what is brieﬂy described
for the entrance ring count above. The acinar volumes for animals 21E and all animals of day 60 are
non-normally distributed, but all acinar volumes per animal are independent (p=5e-29).</p>
<h3 id="alveoli-per-volume">Alveoli per volume</h3>
<p>The mean number of alveoli for the 125 acini at day 4 is 2166±1132 alveoli per mm<sup>3</sup> . For the 58 acini
at day 10 we counted 2831±1189 alveoli per mm<sup>3</sup>, for the 42 acini at day 21 2723±771 alveoli per mm<sup>3</sup>
and for the 43 acini at day 60 1080±349 alveoli per mm<sup>3</sup>. These numbers were found by dividing the
counted entrance rings by the acinus volumes.</p>
<p>The numbers for the single animals are shown in table <a href="#tbl:density">3</a> and displayed in figure ??.</p>
<div id="tbl:density" class="tablenos">
<table>
<caption><span>Table 3:</span> Details of alveolar density (number per mm<sup>3</sup>) per acinus volume for each animal. </caption>
<colgroup>
<col style="width: 7%" />
<col style="width: 18%" />
<col style="width: 19%" />
<col style="width: 14%" />
<col style="width: 19%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr class="header">
<th>Animal</th>
<th>Assessed acini</th>
<th>Average [mm^-3]</th>
<th>STD [mm^-3]</th>
<th>Minimum [mm^-3]</th>
<th>Maximum [mm^-3]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>04A</td>
<td>51</td>
<td>3124</td>
<td>1152</td>
<td>1618</td>
<td>8208</td>
</tr>
<tr class="even">
<td>04B</td>
<td>23</td>
<td>1363</td>
<td>499</td>
<td>679</td>
<td>2704</td>
</tr>
<tr class="odd">
<td>04C</td>
<td>51</td>
<td>1569</td>
<td>380</td>
<td>799</td>
<td>2775</td>
</tr>
<tr class="even">
<td>10A</td>
<td>27</td>
<td>2685</td>
<td>1022</td>
<td>1246</td>
<td>5582</td>
</tr>
<tr class="odd">
<td>10B</td>
<td>14</td>
<td>3091</td>
<td>1166</td>
<td>1890</td>
<td>5422</td>
</tr>
<tr class="even">
<td>10C</td>
<td>17</td>
<td>2848</td>
<td>1462</td>
<td>1182</td>
<td>7009</td>
</tr>
<tr class="odd">
<td>21B</td>
<td>14</td>
<td>2642</td>
<td>493</td>
<td>1625</td>
<td>3344</td>
</tr>
<tr class="even">
<td>21D</td>
<td>17</td>
<td>2534</td>
<td>895</td>
<td>1111</td>
<td>4032</td>
</tr>
<tr class="odd">
<td>21E</td>
<td>11</td>
<td>3119</td>
<td>775</td>
<td>1604</td>
<td>4379</td>
</tr>
<tr class="even">
<td>60B</td>
<td>24</td>
<td>1249</td>
<td>297</td>
<td>530</td>
<td>1912</td>
</tr>
<tr class="odd">
<td>60D</td>
<td>10</td>
<td>838</td>
<td>271</td>
<td>476</td>
<td>1221</td>
</tr>
<tr class="even">
<td>60E</td>
<td>9</td>
<td>898</td>
<td>323</td>
<td>411</td>
<td>1463</td>
</tr>
</tbody>
</table>
</div>
<div id="fig:04" class="fignos">
<figure>
<img src="images/fig04.png" alt="" /><figcaption><span>Figure 4:</span> Number of alveoli per acinus volume. Left: linear scale, right: logarithmic scale. The number
of alveoli per acinus volume are all significantly different (all p-values are better than 5e-5, which is the
one between days 4 and 21) for each combination of days except between days 10 and 21 (p=0.7).</figcaption>
</figure>
</div>
<p>The counts per volume, which correspond to the number of alveoli per acinus volume are a value for
estimating the complexity of the single acini. This acinus complexity shows highly significant differences
between all possible combinations of days except between days 10 and 21 (p=0.7). All other days have a
p-value better than p=5e-5, this being the one between days 4 and 21. The statistical analysis is equal
to what is brieﬂy described for the entrance ring count above. The counts per volume for all animals
except 04A are non-normally distributed, but all are independent (p=2.9e-21).</p>
<h3 id="number-of-acini">Number of acini</h3>
<p>229</p>
<p>The number of acini for day 4 was 18260±16555 acini, for day 10 14359±5611 acini, for day 21 11203±2681
acini and for day 60 4277±777 acini. These numbers were obtained by dividing the parenchymal volume
of the lungs (10) with the Cavalieri-estimated volume of the acini. To calculate these data we had to
use data of two different studies. Most likely due to error propagation, we observed a large standard
deviation. In the end the number of acini do not diﬀer significantly between the days and is not different
to the value published by Barre et al. (8).</p>
<h3 id="total-number-of-alveoli-per-lung">Total number of alveoli per lung</h3>
<p>The total alveolar number for day 4 was found to be 0.64±0.34 million alveoli, for day 10 1.23±0.39
million alveoli, for day 21 2.65±0.57 million alveoli, and for day 60 3.01±0.58 million alveoli. The total
number of acini was estimated by dividing the mean parenchymal volume of the lungs (10), by the
shrinkage-corrected stereologically estimated acinar volume. The number of alveoli is then simply the
multiplication of the average entrance ring count with the estimated number of acini.</p>
<h3 id="volume-of-individual-alveoli">Volume of individual alveoli</h3>
<p>The mean volume of one alveolus for day 4 was 686151 μm<sup>3</sup>, for day 10 452285 μm<sup>3</sup>, for day 21 445373 μm<sup>3</sup>
and for day 60 1053526 μm<sup>3</sup>. This corresponds to an average diameter per alveolus of 109 μm, 95 μm,
95 μm, and 126 μm for days 4, 10, 21 and 60, respectively. The average volume of one alveolus was
estimated by dividing the mean acinar volume by the mean count of alveoli for each day separately.
The average diameter was estimated by assuming spherical alveoli and solving the volume equation of a
sphere to the diameter.</p>
<h2 id="discussion">Discussion</h2>
<p>To our best knowledge, the present manuscript is the first to quantitatively describe the changes in the
volumes of single rat lung acini based on stereological analysis of a large number of individual acini.
In addition, we can easily estimate the number of acini during lung development from our data and
compare this to prior work. There are some limitations to our results though; for technical reasons, we
only assessed the acini in the lower medial tip of the right lower lung lobe. However, it was previously
shown that the right lower lobe is a valid sample for the entire lung (8) and that information drawn from
one lobe is representative for the whole lung (45). Furthermore, based on stereological data, Zeltner
et al. (45) were able to show that the lung parenchyma is quite homogeneous. Looking at individual
acini, Kizhakke Puliyakote et al. (21) observed that the peripheral, pleura facing acini possess an acinar
volume which is two thirds larger than the volume of the central ones. However, they did not report
additional regional differences, e.g. between acini located cranially and caudally. Own preliminary data
are indicative for the same result. We imaged an entire rat lung in situ immediately post mortem
using high resolution synchrotron radiation based X-ray tomographic microscopy (46). A first analysis
of regional difference show similar results as mentioned above. Therefore, we believe that our sample is
more than suitable for the drawn conclusions.</p>
<h3 id="acinus-volumes">Acinus volumes</h3>
<p>The mean acinar volume significantly increases during lung development from postnatal days 10 to 60
with all p-values better than 4.5e-6. No significant difference was observed between postnatal days 4 and
10 (1.2×increase, p=0.08). A large part of the acinus volume increase happens after day 21 (compare
Fig. 3), which is consistent with previous literature (10; 1).</p>
<p>As mentioned in the introduction, Barré et al. (8) have shown that the number of acini remains constant during lung development.
This is somewhat surprising since the total lung volume increases by
roughly a factor of 11 during alveolarization. Therefore, we expect the mean volume of the acini to
increase by at least the same factor (8; 10).</p>
<p>We observed that the mean volume of acini increases 22.66 times between days 4 and 60 (p=1.8e-22) which
corresponds to an approximately 23 times increase of the total lung volume. The other combinations of
increases were: day 4 to day 21: 3.18×(p=1.3e-9), day 10 to day 21: 2.60×(p=4.5e-6), day 10 to day
60: 18.46×(p=1.4e-17), day 21 to day 60: 7.11×(p=7.1e-15). The increase from day 4 to day 10 was not
significant (p=0.08) at 1.23×).</p>
<p>During the same time, the coefficients of variation of the acinus volumes dropped from 1.26 to 0.49 but
the difference between the mean volumes of the fraction of the 20 % smallest and 20 % largest acini
decreased from a factor of 27.47 (day 4) to a factor of 3.94 (day 60). This indicates that the dispersion of
the value is based on an entirely different pattern of distribution of acinar sizes and that the difference of
the mean acinus volumes from the smallest to the largest fraction per day becomes smaller and smaller
during postnatal lung development.</p>
<p>When comparing the acinus volumes normalized to the largest volume per day, we found that the volumes
are closer together on day 4 and are spread out more on the other days (Fig. 5). Additionally, at days
4, 10 and 21 the distribution of the normalized volumes is skewed towards below the average (median of
normalized volumes at day 4: 0.16, at day 10: 0.18 and at day 21: 0.23), which means that we have more
smaller than larger acini early in the development. At day 60, the distribution is more homogeneous,
with the median of the normalized acinus volumes at exactly 0.50. This result let us speculate that acinar
growth is not constant during lung development. It seems that some acini increase their volume faster
than others. As a result we speculate that an increased percentage of acini is somehow dormant at day
4-21, while at day 60 most of the acini reached their final volume.</p>
<p>Figure 5: Normalized acinar volumes. The spread of the volumes is small early in the development and
skewed towards the lower end of the volumes. At day 60, the median is exactly in the middle of the
normalized volumes.</p>
<p>By dividing the parenchymal volumes of each lung estimated by Tschanz et al. (Table 1, (10)) by the
mean number of acini estimated by Barré et al. (9) we can estimate the mean acinar volume for each day.
The acinus volume we estimated by point counting (Cavalieri estimation) are on average 2.07 times lower
but show a similar increase over the studied period (data shown in supplementary Fig. 7).It appears that
the comparison between data obtained by stereology based on classical paraﬃn sections or on any kind of
3D-imaging has it limitation if it comes to the absolute numbers. First, due to the coast of Britain-eﬀect
the exact value of every surface measurement is depending on the resolution of the imaging method (47).
Second, the thickness of the alveolar septa in 3D-imaging data is heavily depending on the segmentation
between airspace and tissue - regardless if it is done manually or by a computed algorithm. We observed
that the airspace volumes obtained by 3D-imaging has a tendency to be smaller than the ones determined
using classical paraﬃn sections. However, the relative numbers obtained in one study match the ones of
other studies quite well.</p>
<h3 id="acinus-complexity-alveoli-per-volume">Acinus complexity, alveoli per volume</h3>
<p>The volume and shape of the alveoli, alveolar ducts, and the acini are critical parameters for ventilation
and particle deposition (48; 49; 50). Particle deposition, for example, is relatively low during the first two
weeks of a rats’ life, high at postnatal day P21 and medium at days P36-P90 (13; 12). This correlates well
with our results, where we found a significantly larger acinus complexity (number of alveoli per acinus
volume) at days 10 and 21 compared to days 4 and 60 (p-values all better than 5.4e-5, which is the one
for day 4 vs. day 21). Kreyling et al. (13) report a maximal retention of gold nanoparticles at this time
point (see their Fig. 1).</p>
<p>Tschanz et al. (10) stereologically estimated the mean total acinar volume as the sum of ductal and
alveolar air spaces. The mean volume of the individual alveoli was found to be smallest around postnatal
day 21 (see their Fig. 4). We thus postulate a high acinar complexity at days 10 and 21 while early and
late in the lung development, the acinar complexity is relatively low. This also correlates with structural
changes. In rats, the alveolar air spaces are large during the first two weeks of life, small at day P21 and
medium afterward (10).</p>
<h3 id="number-of-acini-1">Number of acini</h3>
<p>Previously, it was shown that the number of acini remains constant during postnatal lung development
from day 4 to 60 (8), with a mean of 5612±547 acini per lung. Based on the acinar and parenchymal
volume we calculated the number of acini and were able to verify the previously reported result.</p>
<h3 id="total-alveolar-number">Total alveolar number</h3>
<p>In this study, we assessed the number of alveoli per acinus. The alveolar number we get (0.64±0.34,
1.23±0.39, 2.65±0.57, 3.01±0.58 million alveoli for days 4, 10, 21 and 60, respectively) have to be seen in
the context of the results shown by Tschanz et al. (0.823±0.01, 3.538±1.26, 14.303±3.08 and 19.297±3.06
million alveoli, (10), Table 1). On average, our results are five times smaller but show the same trend
when linearly corrected with a factor of 5.04. The values from Tschanz et al. overlap well with our linearly
scaled values, as seen in Fig. 6.</p>
<p>As shown in a study of Osmanagic et al. (51) the total alveolar number shows a large variability between
different labs. E.g. the reported total number of alveoli in adult C57BL6 mice diﬀers by a factor of
approximately 8. These studies were all performend in labs well-known for their quality of stereologybased investigations of lung morphology. Therefore, any simple bias or methodical error may not account
for the reported differences. It seems to be that the total number of alveoli is dependent on unknown small
methodical differences. However, the relative numbers are surely reliable, especially, if the comparison
is done in groups of animals processed in parallel and counted by the same operator. We assessed the
same lungs as Tschanz et al. (10), but based on a very different imaging method and with two different
persons performing the stereological assessment. The latter two points may explain the factor of 5.04.</p>
<h3 id="volumes-of-individual-alveoli">Volumes of individual alveoli</h3>
<p>By dividing the alveolar air space by the number of alveoli we can estimate a mean alveolar volume of
5.91e5 μm3 for day 4, of 2.49e5 μm3 for day 10, of 1.34e5 μm3 for day 21, and 2.93e5 μm3 for day 60.</p>
<p>Figure 6: Number of alveoli based on data from Tschanz et al. (10) together with our linearly scaled data
(our data multiplied by 5.04). Values are plotted with a band of the width of their standard deviation.</p>
<p>On average, our values are 2.48 times larger than the volumes of the single alveoli as calculated from
data shown in Table 1 of Tschanz et al. (10) (day 4: 6.87e5 μm3 , day 10: 4.52e5 μm3 , day 21 4.45e5 μm3
and day 60 1.05e6 μm3 ), but scale equally during postnatal lung development. Tschanz et al. estimated
the total alveolar volume without the alveolar ducts. Since we directly estimated the volume fraction of
the alveoli per acinus our number is actually expected to be larger.</p>
<h3 id="physiological-relevance-of-the-acinar-size">Physiological relevance of the acinar size</h3>
<p>It has been predicted by computational ﬂuid dynamics simulations and by to-scale experiments that the
amount and location of massless particle deposition, as well as ventilation are depending on the size
of the acini. The predictions could be confirmed at least in one case, where mice received ﬂuorescent
particles during mechanical ventilation. In 3D-visualizations the particles were predominately detected
in the proximal half of the acini (52).</p>
<p>Based on the above-mentioned knowledge and the data of this study, we propose the following. In very
small acini as the smallest ones we observed at postnatal day 4 acinar ﬂows are mainly characterized
by radial streamlines. Massless particle deposition is governed by diﬀusion (53). As the acini increase
in size, convective transport becomes more and more dominant in the proximal regions of the acini.
In larger acini, the proximal region shows a much higher particle retention than the distal once. The
proximal regions may even be viewed analogous to a filter capturing the particles whereas the distal
regions do not receive significant amounts (14; 16; 54).</p>
<p>Multi-breath gas-washout is also dependent on the size of the acini. Based on computational simulations
of nitrogen multi-breath gas-washout it has been shown that small acini washout faster at the beginning
and slower at the end of the washout as compared to larger acini (15). Not surprisingly, the distribution of
the acinar sizes in terms of their range has also an inﬂuence on the gas-washout. Furthermore, a clustering
versus an even distribution of the locations of acinar similar sizes eﬀects gas-washout. Therefore, the
question where an acinus of which size is located in the lungs has a significant inﬂuence on pulmonary
ventilation and particle deposition.</p>
<p>The larger distribution of the acinar sizes at day 4 as compared to day 60 let us speculate what this
may mean biologically. Physiologically, a larger distribution implies a less homogeneous ventilation and
an increased gas-washout time. Therefore, the decrease of the inhomogeneity of the acinar sizes may be
understood as an optimization of gas-exchange in adult animals.</p>
<p>The consideration of the location is not only a theoretical consideration, because it has been shown in
adult mice that the acini close to the pleura are larger than central ones (21). Therefore, acini of different
size are not evenly distributed in the lungs.</p>
<p>To our best knowledge, very few data characterizing acinar properties was available up to now. This is
especially true for lung development. Therefore, the data of the hereby presented study can contribute
to the improvements of computational simulations of pulmonary ventilation and particle deposition.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We conclude that our method is well suited to efficiently extract precise qualitative and quantitative values of large amounts of single acini from non-destructive three-dimensional tomographic data sets.
The underlying stereological analysis can be efficiently performed on tomographic data sets, the analysis of the stereological data was performed in a reproducible manner.
Besides, our method enabled us to maximize the number of investigations per sample, thus reducing the number of sacrificed animals.
We conclude that newly formed acini show a large size distribution which is reduced by a factor of 7 until adulthood.
Most likely the latter leads to a more homogeneous ventilation of the lung and an increase of gas-washout which is equal to a decreased in the number of breaths needed for gas-washout.</p>
<h2 id="acknowledgments">Acknowledgments</h2>
<p>We thank Mohammed Ouanella and Bettina de Breuyn for expert technical assistance.
Federica Marone and Bernd Pinzer were of paramount importance with their support at the TOMCAT beamline.
Fluri Wieland was of great help with the statistical analysis.</p>
<p>We are thankful for the support by the Swiss National Science Foundation (grants 310030_153468 and 310030_175953).</p>
<h2 id="contributions">Contributions</h2>
<p>JS conceived the project.
DH, SB and JS performed the tomographic data acquisition.
DH segmented the acini.
EY and DH analyzed the acini stereologically.
DH, ST, TC and JS analyzed the data.
DH wrote the manuscript and generated all the figures.
ST and JS contributed to writing, all authors proof-read the manuscript.</p>
<h2 id="disclosures">Disclosures</h2>
<p>No conﬂicts of interest, financial or otherwise, are declared by the authors.</p>
<h2 id="supplementary-figures">Supplementary figures</h2>
<div id="fig:figs1" class="fignos">
<figure>
<img src="images/figs1.png" alt="" /><figcaption><span>Figure 5:</span> Plot of the mean acinar volumes.
By dividing the parenchymal volumes of each lung estimated by Tschanz et al. (Table 1, (Tschanz 2014)) by the mean number of acini estimated by Barré et al. (9) we can estimate the mean acinar volume for each measured time point (blue plot).
We assessed the volumes of the acini by point counting (Cavalieri estimation, orange plot).
Our volumes of the acini are on average 2.07 times lower but show a similar increase over the studied period.
While the estimation based on Tschanz et al. is from the entire right middle lobe and on Barré et al. globally for the whole organ, our estimation is solely based on the stereological analysis of the acini in the lower medial tip of the right lower lung lobe.</figcaption>
</figure>
</div>
<div id="fig:figs2" class="fignos">
<figure>
<img src="images/figs2.png" alt="" /><figcaption><span>Figure 6:</span> Plot of the estimated number of acini.
The blue plot shows our estimation, based on the division of the parenchymal volume by the average volume of the acini.
The orange plot is based on the data shown by Barre et al. (9; 8).</figcaption>
</figure>
</div>
<h2 class="page_break_before" id="references">References</h2>
<!-- Explicitly insert bibliography here -->
<div id="refs" role="doc-bibliography">

</div>
<!-- default theme -->

<style>
    /* import google fonts */
    @import url("https://fonts.googleapis.com/css?family=Open+Sans:400,600,700");
    @import url("https://fonts.googleapis.com/css?family=Source+Code+Pro");

    /* -------------------------------------------------- */
    /* global */
    /* -------------------------------------------------- */

    /* all elements */
    * {
        /* force sans-serif font unless specified otherwise */
        font-family: "Open Sans", "Helvetica", sans-serif;

        /* prevent text inflation on some mobile browsers */
        -webkit-text-size-adjust: none !important;
        -moz-text-size-adjust: none !important;
        -o-text-size-adjust: none !important;
        text-size-adjust: none !important;
    }

    @media only screen {
        /* "page" element */
        body {
            position: relative;
            box-sizing: border-box;
            font-size: 12pt;
            line-height: 1.5;
            max-width: 8.5in;
            margin: 20px auto;
            padding: 40px;
            border-radius: 5px;
            border: solid 1px #bdbdbd;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            background: #ffffff;
        }
    }

    /* when on screen < 8.5in wide */
    @media only screen and (max-width: 8.5in) {
        /* "page" element */
        body {
            padding: 20px;
            margin: 0;
            border-radius: 0;
            border: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05) inset;
            background: none;
        }
    }

    /* -------------------------------------------------- */
    /* headings */
    /* -------------------------------------------------- */

    /* all headings */
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
        margin: 20px 0;
        padding: 0;
        font-weight: bold;
    }

    /* biggest heading */
    h1 {
        margin: 40px 0;
        text-align: center;
    }

    /* second biggest heading */
    h2 {
        margin-top: 30px;
        padding-bottom: 5px;
        border-bottom: solid 1px #bdbdbd;
    }

    /* heading font sizes */
    h1 {
        font-size: 2em;
    }
    h2 {
        font-size: 1.5em;
    }
    h3{
        font-size: 1.35em;
    }
    h4 {
        font-size: 1.25em;
    }
    h5 {
        font-size: 1.15em;
    }
    h6 {
        font-size: 1em;
    }

    /* -------------------------------------------------- */
    /* manuscript header */
    /* -------------------------------------------------- */

    /* manuscript title */
    header > h1 {
        margin: 0;
    }

    /* manuscript title caption text (ie "automatically generated on") */
    header + p {
        text-align: center;
        margin-top: 10px;
    }

    /* -------------------------------------------------- */
    /* text elements */
    /* -------------------------------------------------- */

    /* links */
    a {
        color: #2196f3;
        overflow-wrap: break-word;
    }

    /* normal links (not empty, not button link, not syntax highlighting link) */
    a:not(:empty):not(.button):not(.sourceLine) {
        padding-left: 1px;
        padding-right: 1px;
    }

    /* superscripts and subscripts */
    sub,
    sup {
        /* prevent from affecting line height */
        line-height: 0;
    }

    /* unordered and ordered lists*/
    ul,
    ol {
        padding-left: 20px;
    }

    /* class for styling text semibold */
    .semibold {
        font-weight: 600;
    }

    /* class for styling elements horizontally left aligned */
    .left {
        display: block;
        text-align: left;
        margin-left: auto;
        margin-right: 0;
        justify-content: left;
    }

    /* class for styling elements horizontally centered */
    .center {
        display: block;
        text-align: center;
        margin-left: auto;
        margin-right: auto;
        justify-content: center;
    }

    /* class for styling elements horizontally right aligned */
    .right {
        display: block;
        text-align: right;
        margin-left: 0;
        margin-right: auto;
        justify-content: right;
    }

    /* -------------------------------------------------- */
    /* section elements */
    /* -------------------------------------------------- */

    /* horizontal divider line */
    hr {
        border: none;
        height: 1px;
        background: #bdbdbd;
    }

    /* paragraphs, horizontal dividers, figures, tables, code */
    p,
    hr,
    figure,
    table,
    pre {
        /* treat all as "paragraphs", with consistent vertical margins */
        margin-top: 20px;
        margin-bottom: 20px;
    }

    /* -------------------------------------------------- */
    /* figures */
    /* -------------------------------------------------- */

    /* figure */
    figure {
        max-width: 100%;
        margin-left: auto;
        margin-right: auto;
    }

    /* figure caption */
    figcaption {
        padding: 0;
        padding-top: 10px;
    }

    /* figure image element */
    figure > img,
    figure > svg {
        max-width: 100%;
        display: block;
        margin-left: auto;
        margin-right: auto;
    }

    /* figure auto-number */
    img + figcaption > span:first-of-type,
    svg + figcaption > span:first-of-type {
        font-weight: bold;
        margin-right: 5px;
    }

    /* -------------------------------------------------- */
    /* tables */
    /* -------------------------------------------------- */

    /* table */
    table {
        border-collapse: collapse;
        border-spacing: 0;
        width: 100%;
        margin-left: auto;
        margin-right: auto;
    }

    /* table cells */
    th,
    td {
        border: solid 1px #bdbdbd;
        padding: 10px;
        /* squash table if too wide for page by forcing line breaks */
        overflow-wrap: break-word;
        word-break: break-word;
    }

    /* header row and even rows */
    th,
    tr:nth-child(2n) {
        background-color: #fafafa;
    }

    /* odd rows */
    tr:nth-child(2n + 1) {
        background-color: #ffffff;
    }

    /* table caption */
    caption {
        text-align: left;
        padding: 0;
        padding-bottom: 10px;
    }

    /* table auto-number */
    table > caption > span:first-of-type,
    div.table_wrapper > table > caption > span:first-of-type {
        font-weight: bold;
        margin-right: 5px;
    }

    /* -------------------------------------------------- */
    /* code */
    /* -------------------------------------------------- */

    /* multi-line code block */
    pre {
        padding: 10px;
        background-color: #eeeeee;
        color: #000000;
        border-radius: 5px;
        break-inside: avoid;
        text-align: left;
    }

    /* inline code, ie code within normal text */
    :not(pre) > code {
        padding: 0 4px;
        background-color: #eeeeee;
        color: #000000;
        border-radius: 5px;
    }

    /* code text */
    /* apply all children, to reach syntax highlighting sub-elements */
    code,
    code * {
        /* force monospace font */
        font-family: "Source Code Pro", "Courier New", monospace;
    }

    /* -------------------------------------------------- */
    /* quotes */
    /* -------------------------------------------------- */

    /* quoted text */
    blockquote {
        margin: 0;
        padding: 0;
        border-left: 4px solid #bdbdbd;
        padding-left: 16px;
        break-inside: avoid;
    }

    /* -------------------------------------------------- */
    /* banners */
    /* -------------------------------------------------- */

    /* info banners */
    .banner {
        box-sizing: border-box;
        display: block;
        position: relative;
        width: 100%;
        margin-top: 20px;
        margin-bottom: 20px;
        padding: 20px;
        text-align: center;
    }

    /* paragraph in banner */
    .banner > p {
        margin: 0;
    }

    /* -------------------------------------------------- */
    /* highlight colors */
    /* -------------------------------------------------- */

    .white {
        background: #ffffff;
    }
    .lightgrey {
        background: #eeeeee;
    }
    .grey {
        background: #757575;
    }
    .darkgrey {
        background: #424242;
    }
    .black {
        background: #000000;
    }
    .lightred {
        background: #ffcdd2;
    }
    .lightyellow {
        background: #ffecb3;
    }
    .lightgreen {
        background: #dcedc8;
    }
    .lightblue {
        background: #e3f2fd;
    }
    .lightpurple {
        background: #f3e5f5;
    }
    .red {
        background: #f44336;
    }
    .orange {
        background: #ff9800;
    }
    .yellow {
        background: #ffeb3b;
    }
    .green {
        background: #4caf50;
    }
    .blue {
        background: #2196f3;
    }
    .purple {
        background: #9c27b0;
    }
    .white,
    .lightgrey,
    .lightred,
    .lightyellow,
    .lightgreen,
    .lightblue,
    .lightpurple,
    .orange,
    .yellow,
    .white a,
    .lightgrey a,
    .lightred a,
    .lightyellow a,
    .lightgreen a,
    .lightblue a,
    .lightpurple a,
    .orange a,
    .yellow a {
        color: #000000;
    }
    .grey,
    .darkgrey,
    .black,
    .red,
    .green,
    .blue,
    .purple,
    .grey a,
    .darkgrey a,
    .black a,
    .red a,
    .green a,
    .blue a,
    .purple a {
        color: #ffffff;
    }

    /* -------------------------------------------------- */
    /* buttons */
    /* -------------------------------------------------- */

    /* class for styling links like buttons */
    .button {
        display: inline-flex;
        justify-content: center;
        align-items: center;
        margin: 5px;
        padding: 10px 20px;
        font-size: 0.75em;
        font-weight: 600;
        text-transform: uppercase;
        text-decoration: none;
        letter-spacing: 1px;
        background: none;
        color: #2196f3;
        border: solid 1px #bdbdbd;
        border-radius: 5px;
    }

    /* buttons when hovered */
    .button:hover:not([disabled]),
    .icon_button:hover:not([disabled]) {
        cursor: pointer;
        background: #f5f5f5;
    }

    /* buttons when disabled */
    .button[disabled],
    .icon_button[disabled] {
        opacity: 0.35;
        pointer-events: none;
    }

    /* class for styling buttons containg only single icon */
    .icon_button {
        display: inline-flex;
        justify-content: center;
        align-items: center;
        text-decoration: none;
        margin: 0;
        padding: 0;
        background: none;
        border-radius: 5px;
        border: none;
        width: 20px;
        height: 20px;
        min-width: 20px;
        min-height: 20px;
    }

    /* icon button inner svg image */
    .icon_button > svg {
        height: 16px;
    }

    /* -------------------------------------------------- */
    /* icons */
    /* -------------------------------------------------- */

    /* class for styling icons inline with text */
    .inline_icon {
        height: 1em;
        position: relative;
        top: 0.125em;
    }

    /* -------------------------------------------------- */
    /* print control */
    /* -------------------------------------------------- */

    @media print {
        @page {
            /* suggested printing margin */
            margin: 0.5in;
        }

        /* document and "page" elements */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }

        /* "page" element */
        body {
            font-size: 11pt !important;
            line-height: 1.35;
        }

        /* all headings */
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            margin: 15px 0;
        }

        /* figures and tables */
        figure, table {
            font-size: 0.85em;
        }

        /* table cells */
        th,
        td {
            padding: 5px;
        }

        /* shrink font awesome icons */
        i.fas,
        i.fab,
        i.far,
        i.fal {
            transform: scale(0.85);
        }

        /* decrease banner margins */
        .banner {
            margin-top: 15px;
            margin-bottom: 15px;
            padding: 15px;
        }

        /* class for centering an element vertically on its own page */
        .page_center {
            margin: auto;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            vertical-align: middle;
            break-before: page;
            break-after: page;
        }

        /* always insert a page break before the element */
        .page_break_before {
            break-before: page;
        }

        /* always insert a page break after the element */
        .page_break_after {
            break-after: page;
        }

        /* avoid page break before the element */
        .page_break_before_avoid {
            break-before: avoid;
        }

        /* avoid page break after the element */
        .page_break_after_avoid {
            break-after: avoid;
        }

        /* avoid page break inside the element */
        .page_break_inside_avoid {
            break-inside: avoid;
        }
    }

    /* -------------------------------------------------- */
    /* override pandoc css quirks */
    /* -------------------------------------------------- */

    .sourceCode {
        /* prevent unsightly overflow in wide code blocks */
        overflow: auto !important;
    }

    div.sourceCode {
        /* prevent background fill on top-most code block  container */
        background: none !important;
    }

    .sourceCode * {
        /* force consistent line spacing */
        line-height: 1.5 !important;
    }

    div.sourceCode {
        /* style code block margins same as <pre> element */
        margin-top: 20px;
        margin-bottom: 20px;
    }

    /* -------------------------------------------------- */
    /* tablenos */
    /* -------------------------------------------------- */

    /* tablenos wrapper */
    .tablenos {
        /* show scrollbar on tables if necessary to prevent overflow */
        width: 100%;
        margin: 20px 0;
    }

    .tablenos > table {
        /* move margins from table to table_wrapper to allow margin collapsing */
        margin: 0;
    }

    @media only screen {
        /* tablenos wrapper */
        .tablenos {
            /* show scrollbar on tables if necessary to prevent overflow */
            overflow-x: auto !important;
        }

        .tablenos th,
        .tablenos td {
            overflow-wrap: unset !important;
            word-break: unset !important;
        }

        /* table in wrapper */
        .tablenos table,
        .tablenos table * {
            /* don't break table words */
            overflow-wrap: normal !important;
        }
    }

    /* -------------------------------------------------- */
    /* mathjax */
    /* -------------------------------------------------- */

    /* mathjax containers */
    .math.display > span:not(.MathJax_Preview) {
        /* turn inline element (no dimensions) into block (allows fixed width and thus scrolling) */
        display: flex !important;
        overflow-x: auto !important;
        overflow-y: hidden !important;
        justify-content: center;
        align-items: center;
        margin: 0 !important;
    }

    /* right click menu */
    .MathJax_Menu {
        border-radius: 5px !important;
        border: solid 1px #bdbdbd !important;
        box-shadow: none !important;
    }

    /* equation auto-number */
    span[id^="eq:"] > span.math.display + span {
        font-weight: 600;
    }

    /* equation */
    span[id^="eq:"] > span.math.display > span {
        /* nudge to make room for equation auto-number and anchor */
        margin-right: 60px !important;
    }

    /* -------------------------------------------------- */
    /* anchors plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* anchor button */
        .anchor {
            opacity: 0;
            margin-left: 5px;
        }

        /* anchor buttons within <h2>'s */
        h2 .anchor {
            margin-left: 10px;
        }

        /* anchor buttons when hovered/focused and anything containing an anchor button when hovered */
        *:hover > .anchor,
        .anchor:hover,
        .anchor:focus {
            opacity: 1;
        }

        /* anchor button when hovered */
        .anchor:hover {
            cursor: pointer;
        }
    }

    /* always show anchor button on devices with no mouse/hover ability */
    @media (hover: none) {
        .anchor {
            opacity: 1;
        }
    }

    /* always hide anchor button on print */
    @media only print {
        .anchor {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* accordion plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* accordion arrow button */
        .accordion_arrow {
            margin-right: 10px;
        }

        /* arrow icon when <h2> data-collapsed attribute true */
        h2[data-collapsed="true"] > .accordion_arrow > svg {
            transform: rotate(-90deg);
        }

        /* all elements (except <h2>'s) when data-collapsed attribute true */
        *:not(h2)[data-collapsed="true"] {
            display: none;
        }

        /* accordion arrow button when hovered and <h2>'s when hovered */
        .accordion_arrow:hover,
        h2[data-collapsed="true"]:hover,
        h2[data-collapsed="false"]:hover {
            cursor: pointer;
        }
    }

    /* always hide accordion arrow button on print */
    @media only print {
        .accordion_arrow {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* tooltips plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* tooltip container */
        #tooltip {
            position: absolute;
            width: 50%;
            min-width: 240px;
            max-width: 75%;
            z-index: 1;
        }

        /* tooltip content */
        #tooltip_content {
            margin-bottom: 5px;
            padding: 20px;
            border-radius: 5px;
            border: solid 1px #bdbdbd;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            background: #ffffff;
            overflow-wrap: break-word;
        }

        /* tooltip copy of paragraphs and figures */
        #tooltip_content > p,
        #tooltip_content > figure {
            margin: 0;
            max-height: 320px;
            overflow-y: auto;
        }

        /* tooltip copy of <img> */
        #tooltip_content > figure > img,
        #tooltip_content > figure > svg {
            max-height: 260px;
        }

        /* navigation bar */
        #tooltip_nav_bar {
            margin-top: 10px;
            text-align: center;
        }

        /* navigation bar previous/next buton */
        #tooltip_nav_bar > .icon_button {
            position: relative;
            top: 3px;
        }

        /* navigation bar previous button */
        #tooltip_nav_bar > .icon_button:first-of-type {
            margin-right: 5px;
        }

        /* navigation bar next button */
        #tooltip_nav_bar > .icon_button:last-of-type {
            margin-left: 5px;
        }
    }

    /* always hide tooltip on print */
    @media only print {
        #tooltip {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* jump to first plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* jump button */
        .jump_arrow {
            position: relative;
            top: 0.125em;
            margin-right: 5px;
        }
    }

    /* always hide jump button on print */
    @media only print {
        .jump_arrow {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* link highlight plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* anything with data-highlighted attribute true */
        [data-highlighted="true"] {
            background: #ffeb3b;
        }

        /* anything with data-selected attribute true */
        [data-selected="true"] {
            background: #ff8a65 !important;
        }

        /* animation definition for glow */
        @keyframes highlight_glow {
            0% {
                background: none;
            }
            10% {
                background: #bbdefb;
            }
            100% {
                background: none;
            }
        }

        /* anything with data-glow attribute true */
        [data-glow="true"] {
            animation: highlight_glow 2s;
        }
    }

    /* -------------------------------------------------- */
    /* table of contents plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* toc panel */
        #toc_panel {
            box-sizing: border-box;
            position: fixed;
            top: 0;
            left: 0;
            background: #ffffff;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            z-index: 2;
        }

        /* toc panel when closed */
        #toc_panel[data-open="false"] {
            min-width: 60px;
            width: 60px;
            height: 60px;
            border-right: solid 1px #bdbdbd;
            border-bottom: solid 1px #bdbdbd;
        }

        /* toc panel when open */
        #toc_panel[data-open="true"] {
            min-width: 260px;
            max-width: 480px;
            /* keep panel edge consistent distance away from "page" edge */
            width: calc(((100vw - 8.5in) / 2) - 30px - 40px);
            bottom: 0;
            border-right: solid 1px #bdbdbd;
        }

        /* toc panel header */
        #toc_header {
            box-sizing: border-box;
            display: flex;
            flex-direction: row;
            align-items: center;
            height: 60px;
            margin: 0;
            padding: 20px;
        }

        /* toc panel header when hovered */
        #toc_header:hover {
            cursor: pointer;
        }

        /* toc panel header when panel open */
        #toc_panel[data-open="true"] > #toc_header {
            border-bottom: solid 1px #bdbdbd;
        }

        /* toc open/close header button */
        #toc_button {
            margin-right: 20px;
        }

        /* hide toc list and header text when closed */
        #toc_panel[data-open="false"] > #toc_header > *:not(#toc_button),
        #toc_panel[data-open="false"] > #toc_list {
            display: none;
        }

        /* toc list of entries */
        #toc_list {
            box-sizing: border-box;
            width: 100%;
            padding: 20px;
            position: absolute;
            top: calc(60px + 1px);
            bottom: 0;
            overflow: auto;
        }

        /* toc entry, link to section in document */
        .toc_link {
            display: block;
            padding: 5px;
            position: relative;
            font-weight: 600;
            text-decoration: none;
        }

        /* toc entry when hovered or when "viewed" */
        .toc_link:hover,
        .toc_link[data-viewing="true"] {
            background: #f5f5f5;
        }

        /* toc entry, level 1 indentation */
        .toc_link[data-level="1"] {
            margin-left: 0;
        }

        /* toc entry, level 2 indentation */
        .toc_link[data-level="2"] {
            margin-left: 20px;
        }

        /* toc entry, level 3 indentation */
        .toc_link[data-level="3"] {
            margin-left: 40px;
        }

        /* toc entry, level 4 indentation */
        .toc_link[data-level="4"] {
            margin-left: 60px;
        }

        /* toc entry bullets */
        #toc_panel[data-bullets="true"] .toc_link[data-level]:before {
            position: absolute;
            left: -15px;
            top: -1px;
            font-size: 1.5em;
        }

        /* toc entry, level 2 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="2"]:before {
            content: "\2022";
        }

        /* toc entry, level 3 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="3"]:before {
            content: "\25AB";
        }

        /* toc entry, level 4 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="4"]:before {
            content: "-";
        }
    }

    /* when on screen < 8.5in wide */
    @media only screen and (max-width: 8.5in) {
        /* push <body> ("page") element down to make room for toc icon */
        .toc_body_nudge {
            padding-top: 60px;
        }

        /* toc icon when panel closed and not hovered */
        #toc_panel[data-open="false"]:not(:hover) {
            background: rgba(255, 255, 255, 0.75);
        }
    }

    /* always hide toc panel on print */
    @media only print {
        #toc_panel {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* lightbox plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* regular <img> in document when hovered */
        img.lightbox_document_img:hover {
            cursor: pointer;
        }

        .body_no_scroll {
            overflow: hidden !important;
        }

        /* screen overlay */
        #lightbox_overlay {
            display: flex;
            flex-direction: column;
            position: fixed;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            z-index: 3;
        }

        /* middle area containing lightbox image */
        #lightbox_image_container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            padding: 20px;
        }

        /* bottom area containing caption */
        #lightbox_bottom_container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            min-height: 100px;
            max-height: 100px;
            background: rgba(0, 0, 0, 0.5);
        }

        /* image number info text box */
        #lightbox_number_info {
            position: absolute;
            color: #ffffff;
            font-weight: 600;
            left: 2px;
            top: 0;
            z-index: 4;
        }

        /* zoom info text box */
        #lightbox_zoom_info {
            position: absolute;
            color: #ffffff;
            font-weight: 600;
            right: 2px;
            top: 0;
            z-index: 4;
        }

        /* copy of image caption */
        #lightbox_caption {
            box-sizing: border-box;
            display: inline-block;
            width: 100%;
            max-height: 100%;
            padding: 10px 0;
            text-align: center;
            overflow-y: auto;
            color: #ffffff;
        }

        /* navigation previous/next button */
        .lightbox_button {
            width: 100px;
            height: 100%;
            min-width: 100px;
            min-height: 100%;
            color: #ffffff;
        }

        /* navigation previous/next button when hovered */
        .lightbox_button:hover {
            background: none !important;
        }

        /* navigation button icon */
        .lightbox_button > svg {
            height: 25px;
        }

        /* figure auto-number */
        #lightbox_caption > span:first-of-type {
            font-weight: bold;
            margin-right: 5px;
        }

        /* lightbox image when hovered */
        #lightbox_img:hover {
            cursor: grab;
        }

        /* lightbox image when grabbed */
        #lightbox_img:active {
            cursor: grabbing;
        }
    }

    /* when on screen < 480px wide */
    @media only screen and (max-width: 480px) {
        /* make navigation buttons skinnier on small screens to make more room for caption text */
        .lightbox_button {
            width: 50px;
            min-width: 50px;
        }
    }

    /* always hide lightbox on print */
    @media only print {
        #lightbox_overlay {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* hypothesis (annotations) plugin */
    /* -------------------------------------------------- */

    /* hypothesis activation button */
    #hypothesis_button {
        box-sizing: border-box;
        position: fixed;
        top: 0;
        right: 0;
        width: 60px;
        height: 60px;
        background: #ffffff;
        border-radius: 0;
        border-left: solid 1px #bdbdbd;
        border-bottom: solid 1px #bdbdbd;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
        z-index: 2;
    }

    /* hypothesis button svg */
    #hypothesis_button > svg {
        position: relative;
        top: -4px;
    }

    /* hypothesis annotation count */
    #hypothesis_count {
        position: absolute;
        left: 0;
        right: 0;
        bottom: 5px;
    }

    /* side panel */
    .annotator-frame {
        width: 280px !important;
    }

    /* match highlight color to rest of theme */
    .annotator-highlights-always-on .annotator-hl {
        background-color: #ffeb3b !important;
    }

    /* match focused color to rest of theme */
    .annotator-hl.annotator-hl-focused {
        background-color: #ff8a65 !important;
    }

    /* match bucket bar color to rest of theme */
    .annotator-bucket-bar {
        background: #f5f5f5 !important;
    }

    /* always hide button, toolbar, and tooltip on print */
    @media only print {
        #hypothesis_button {
            display: none;
        }

        .annotator-frame {
            display: none !important;
        }

        hypothesis-adder {
            display: none !important;
        }
    }
</style>
<!-- anchors plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin adds an anchor next to each of a certain type
        // of element that provides a human-readable url to that specific
        // item/position in the document (eg "manuscript.html#abstract"). It
        // also makes it such that scrolling out of view of a target removes
        // its identifier from the url.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'anchors';

        // default plugin options
        const options = {
            // which types of elements to add anchors next to, in
            // "document.querySelector" format
            typesQuery: 'h1, h2, h3, [id^="fig:"], [id^="tbl:"], [id^="eq:"]',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // add anchor to each element of specified types
            const elements = document.querySelectorAll(options.typesQuery);
            for (const element of elements)
                addAnchor(element);

            // attach scroll listener to window
            window.addEventListener('scroll', onScroll);
        }

        // when window is scrolled
        function onScroll() {
            // if url has hash and user has scrolled out of view of hash
            // target, remove hash from url
            const tolerance = 100;
            const target = getHashTarget();
            if (target) {
                if (
                    target.getBoundingClientRect().top >
                        window.innerHeight + tolerance ||
                    target.getBoundingClientRect().bottom < 0 - tolerance
                )
                    history.pushState(null, null, ' ');
            }
        }

        // add anchor to element
        function addAnchor(element) {
            let addTo; // element to add anchor button to

            // if figure or table, modify withId and addTo to get expected
            // elements
            if (element.id.indexOf('fig:') === 0) {
                addTo = element.querySelector('figcaption');
            } else if (element.id.indexOf('tbl:') === 0) {
                addTo = element.querySelector('caption');
            } else if (element.id.indexOf('eq:') === 0) {
                addTo = element.querySelector('.eqnos-number');
            }

            addTo = addTo || element;
            const id = element.id || null;

            // do not add anchor if element doesn't have assigned id.
            // id is generated by pandoc and is assumed to be unique and
            // human-readable
            if (!id)
                return;

            // create anchor button
            const anchor = document.createElement('a');
            anchor.innerHTML = document.querySelector('.icon_link').innerHTML;
            anchor.title = 'Link to this part of the document';
            anchor.classList.add('icon_button', 'anchor');
            anchor.dataset.ignore = 'true';
            anchor.href = '#' + id;
            addTo.appendChild(anchor);
        }

        // get element that is target of link or url hash
        function getHashTarget() {
            const hash = window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector('[id="' + id + '"]');
            if (!target)
                return;

            // if figure or table, modify target to get expected element
            if (id.indexOf('fig:') === 0)
                target = target.querySelector('figure');
            if (id.indexOf('tbl:') === 0)
                target = target.querySelector('table');

            return target;
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- link icon -->

<template class="icon_link">
    <!-- modified from: https://fontawesome.com/icons/link -->
    <svg width="16" height="16" viewBox="0 0 512 512">
        <path
            fill="currentColor"
            d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"
        ></path>
    </svg>
</template>
<!-- accordion plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin allows sections of content under <h2> headings
        // to be collapsible.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'accordion';

        // default plugin options
        const options = {
            // whether to always start expanded ('false'), always start
            // collapsed ('true'), or start collapsed when screen small ('auto')
            startCollapsed: 'auto',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // run through each <h2> heading
            const headings = document.querySelectorAll('h2');
            for (const heading of headings) {
                addArrow(heading);

                // start expanded/collapsed based on option
                if (
                    options.startCollapsed === 'true' ||
                    (options.startCollapsed === 'auto' && isSmallScreen())
                )
                    collapseHeading(heading);
                else
                    expandHeading(heading);
            }

            // attach hash change listener to window
            window.addEventListener('hashchange', onHashChange);
        }

        // when hash (eg manuscript.html#introduction) changes
        function onHashChange() {
            const target = getHashTarget();
            if (target)
                goToElement(target);
        }

        // add arrow to heading
        function addArrow(heading) {
            // add arrow button
            const arrow = document.createElement('button');
            arrow.innerHTML = document.querySelector(
                '.icon_angle_down'
            ).innerHTML;
            arrow.classList.add('icon_button', 'accordion_arrow');
            heading.insertBefore(arrow, heading.firstChild);

            // attach click listener to heading and button
            heading.addEventListener('click', onHeadingClick);
            arrow.addEventListener('click', onArrowClick);
        }

        // determine if on mobile-like device with small screen
        function isSmallScreen() {
            return Math.min(window.innerWidth, window.innerHeight) < 480;
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // get element that is target of hash
        function getHashTarget(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector('[id="' + id + '"]');
            if (!target)
                return;

            // if figure or table, modify target to get expected element
            if (id.indexOf('fig:') === 0)
                target = target.querySelector('figure');
            if (id.indexOf('tbl:') === 0)
                target = target.querySelector('table');

            return target;
        }

        // when <h2> heading is clicked
        function onHeadingClick(event) {
            // only collapse if <h2> itself is target of click (eg, user did
            // not click on anchor within <h2>)
            if (event.target === this)
                toggleCollapse(this);
        }

        // when arrow button is clicked
        function onArrowClick() {
            toggleCollapse(this.parentNode);
        }

        // collapse section if expanded, expand if collapsed
        function toggleCollapse(heading) {
            if (heading.dataset.collapsed === 'false')
                collapseHeading(heading);
            else
                expandHeading(heading);
        }

        // elements to exclude from collapse, such as table of contents panel,
        // hypothesis panel, etc
        const exclude = '#toc_panel, div.annotator-frame, #lightbox_overlay';

        // collapse section
        function collapseHeading(heading) {
            heading.setAttribute('data-collapsed', 'true');
            const children = getChildren(heading);
            for (const child of children)
                child.setAttribute('data-collapsed', 'true');
        }

        // expand section
        function expandHeading(heading) {
            heading.setAttribute('data-collapsed', 'false');
            const children = getChildren(heading);
            for (const child of children)
                child.setAttribute('data-collapsed', 'false');
        }

        // get list of elements between this <h2> and next <h2> or <h1>
        // ("children" of the <h2> section)
        function getChildren(heading) {
            return nextUntil(heading, 'h2, h1', exclude);
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get list of elements after a start element up to element matching
        // query
        function nextUntil(element, query, exclude) {
            const elements = [];
            while (element = element.nextElementSibling, element) {
                if (element.matches(query))
                    break;
                if (!element.matches(exclude))
                    elements.push(element);
            }
            return elements;
        }

        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- angle down icon -->

<template class="icon_angle_down">
    <!-- modified from: https://fontawesome.com/icons/angle-down -->
    <svg width="16" height="16" viewBox="0 0 448 512">
        <path
            fill="currentColor"
            d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"
        ></path>
    </svg>
</template>
<!-- tooltips plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when the user hovers or
        // focuses a link to a citation or figure, a tooltip appears with a
        // preview of the reference content, along with arrows to navigate
        // between instances of the same reference in the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'tooltips';

        // default plugin options
        const options = {
            // whether user must click off to close tooltip instead of just
            // un-hovering
            clickClose: 'false',
            // delay (in ms) between opening and closing tooltip
            delay: '100',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            const links = getLinks();
            for (const link of links) {
                // attach hover and focus listeners to link
                link.addEventListener('mouseover', onLinkHover);
                link.addEventListener('mouseleave', onLinkUnhover);
                link.addEventListener('focus', onLinkFocus);
                link.addEventListener('touchend', onLinkTouch);
            }

            // attach mouse, key, and resize listeners to window
            window.addEventListener('mousedown', onClick);
            window.addEventListener('touchstart', onClick);
            window.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onResize);
        }

        // when link is hovered
        function onLinkHover() {
            // function to open tooltip
            const delayOpenTooltip = function() {
                openTooltip(this);
            }.bind(this);

            // run open function after delay
            this.openTooltipTimer = window.setTimeout(
                delayOpenTooltip,
                options.delay
            );
        }

        // when mouse leaves link
        function onLinkUnhover() {
            // cancel opening tooltip
            window.clearTimeout(this.openTooltipTimer);

            // don't close on unhover if option specifies
            if (options.clickClose === 'true')
                return;

            // function to close tooltip
            const delayCloseTooltip = function() {
                // if tooltip open and if mouse isn't over tooltip, close
                const tooltip = document.getElementById('tooltip');
                if (tooltip && !tooltip.matches(':hover'))
                    closeTooltip();
            };

            // run close function after delay
            this.closeTooltipTimer = window.setTimeout(
                delayCloseTooltip,
                options.delay
            );
        }

        // when link is focused (tabbed to)
        function onLinkFocus(event) {
            openTooltip(this);
        }

        // when link is touched on touch screen
        function onLinkTouch(event) {
            // attempt to force hover state on first tap always, and trigger
            // regular link click (and navigation) on second tap
            if (event.target === document.activeElement)
                event.target.click();
            else {
                document.activeElement.blur();
                event.target.focus();
            }
            if (event.cancelable)
                event.preventDefault();
            event.stopPropagation();
            return false;
        }

        // when mouse is clicked anywhere in window
        function onClick(event) {
            closeTooltip();
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            switch (event.key) {
                // trigger click of prev button
                case 'ArrowLeft':
                    const prevButton = document.getElementById(
                        'tooltip_prev_button'
                    );
                    if (prevButton)
                        prevButton.click();
                    break;
                // trigger click of next button
                case 'ArrowRight':
                    const nextButton = document.getElementById(
                        'tooltip_next_button'
                    );
                    if (nextButton)
                        nextButton.click();
                    break;
                // close on esc
                case 'Escape':
                    closeTooltip();
                    break;
            }
        }

        // when window is resized or zoomed
        function onResize() {
            closeTooltip();
        }

        // get all links of types we wish to handle
        function getLinks() {
            const queries = [];
            // exclude buttons, anchor links, toc links, etc
            const exclude =
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            queries.push('a[href^="#ref-"]' + exclude); // citation links
            queries.push('a[href^="#fig:"]' + exclude); // figure links
            const query = queries.join(', ');
            return document.querySelectorAll(query);
        }

        // get links with same target, get index of link in set, get total
        // same links
        function getSameLinks(link) {
            const sameLinks = [];
            const links = getLinks();
            for (const otherLink of links) {
                if (
                    otherLink.getAttribute('href') === link.getAttribute('href')
                )
                    sameLinks.push(otherLink);
            }

            return {
                elements: sameLinks,
                index: sameLinks.indexOf(link),
                total: sameLinks.length
            };
        }

        // open tooltip
        function openTooltip(link) {
            // delete tooltip if it exists, start fresh
            closeTooltip();

            // make tooltip element
            const tooltip = makeTooltip(link);

            // if source couldn't be found and tooltip not made, exit
            if (!tooltip)
                return;

            // make navbar elements
            const navBar = makeNavBar(link);
            if (navBar)
                tooltip.firstElementChild.appendChild(navBar);

            // attach tooltip to page
            document.body.appendChild(tooltip);

            // position tooltip
            const position = function() {
                positionTooltip(link);
            };
            position();

            // if tooltip contains images, position again after they've loaded
            const imgs = tooltip.querySelectorAll('img');
            for (const img of imgs)
                img.addEventListener('load', position);
        }

        // close (delete) tooltip
        function closeTooltip() {
            const tooltip = document.getElementById('tooltip');
            if (tooltip)
                tooltip.remove();
        }

        // make tooltip
        function makeTooltip(link) {
            // get target element that link points to
            const source = getSource(link);

            // if source can't be found, exit
            if (!source)
                return;

            // create new tooltip
            const tooltip = document.createElement('div');
            tooltip.id = 'tooltip';
            const tooltipContent = document.createElement('div');
            tooltipContent.id = 'tooltip_content';
            tooltip.appendChild(tooltipContent);

            // make copy of source node and put in tooltip
            const sourceCopy = makeCopy(source);
            tooltipContent.appendChild(sourceCopy);

            // attach mouse event listeners
            tooltip.addEventListener('click', onTooltipClick);
            tooltip.addEventListener('mousedown', onTooltipClick);
            tooltip.addEventListener('touchstart', onTooltipClick);
            tooltip.addEventListener('mouseleave', onTooltipUnhover);

            // (for interaction with lightbox plugin)
            // transfer click on tooltip copied img to original img
            const sourceImg = source.querySelector('img');
            const sourceCopyImg = sourceCopy.querySelector('img');
            if (sourceImg && sourceCopyImg) {
                const clickImg = function() {
                    sourceImg.click();
                    closeTooltip();
                };
                sourceCopyImg.addEventListener('click', clickImg);
            }

            return tooltip;
        }

        // make carbon copy of html dom element
        function makeCopy(source) {
            const sourceCopy = source.cloneNode(true);

            // delete elements marked with ignore (eg anchor and jump buttons)
            const deleteFromCopy = sourceCopy.querySelectorAll(
                '[data-ignore="true"]'
            );
            for (const element of deleteFromCopy)
                element.remove();

            // delete certain element attributes
            const attributes = [
                'id',
                'data-collapsed',
                'data-selected',
                'data-highlighted',
                'data-glow'
            ];
            for (const attribute of attributes) {
                sourceCopy.removeAttribute(attribute);
                const elements = sourceCopy.querySelectorAll(
                    '[' + attribute + ']'
                );
                for (const element of elements)
                    element.removeAttribute(attribute);
            }

            return sourceCopy;
        }

        // when tooltip is clicked
        function onTooltipClick(event) {
            // when user clicks on tooltip, stop click from transferring
            // outside of tooltip (eg, click off to close tooltip, or eg click
            // off to unhighlight same refs)
            event.stopPropagation();
        }

        // when tooltip is unhovered
        function onTooltipUnhover(event) {
            if (options.clickClose === 'true')
                return;

            // make sure new mouse/touch/focus no longer over tooltip or any
            // element within it
            const tooltip = document.getElementById('tooltip');
            if (!tooltip)
                return;
            if (this.contains(event.relatedTarget))
                return;

            closeTooltip();
        }

        // make nav bar to go betwen prev/next instances of same reference
        function makeNavBar(link) {
            // find other links to the same source
            const sameLinks = getSameLinks(link);

            // don't show nav bar when singular reference
            if (sameLinks.total <= 1)
                return;

            // find prev/next links with same target
            const prevLink = getPrevLink(link, sameLinks);
            const nextLink = getNextLink(link, sameLinks);

            // create nav bar
            const navBar = document.createElement('div');
            navBar.id = 'tooltip_nav_bar';
            const text = sameLinks.index + 1 + ' of ' + sameLinks.total;

            // create nav bar prev/next buttons
            const prevButton = document.createElement('button');
            const nextButton = document.createElement('button');
            prevButton.id = 'tooltip_prev_button';
            nextButton.id = 'tooltip_next_button';
            prevButton.title =
                'Jump to the previous occurence of this item in the document [←]';
            nextButton.title =
                'Jump to the next occurence of this item in the document [→]';
            prevButton.classList.add('icon_button');
            nextButton.classList.add('icon_button');
            prevButton.innerHTML = document.querySelector(
                '.icon_caret_left'
            ).innerHTML;
            nextButton.innerHTML = document.querySelector(
                '.icon_caret_right'
            ).innerHTML;
            navBar.appendChild(prevButton);
            navBar.appendChild(document.createTextNode(text));
            navBar.appendChild(nextButton);

            // attach click listeners to buttons
            prevButton.addEventListener('click', function() {
                onPrevNextClick(link, prevLink);
            });
            nextButton.addEventListener('click', function() {
                onPrevNextClick(link, nextLink);
            });

            return navBar;
        }

        // get previous link with same target
        function getPrevLink(link, sameLinks) {
            if (!sameLinks)
                sameLinks = getSameLinks(link);
            // wrap index to other side if < 1
            let index;
            if (sameLinks.index - 1 >= 0)
                index = sameLinks.index - 1;
            else
                index = sameLinks.total - 1;
            return sameLinks.elements[index];
        }

        // get next link with same target
        function getNextLink(link, sameLinks) {
            if (!sameLinks)
                sameLinks = getSameLinks(link);
            // wrap index to other side if > total
            let index;
            if (sameLinks.index + 1 <= sameLinks.total - 1)
                index = sameLinks.index + 1;
            else
                index = 0;
            return sameLinks.elements[index];
        }

        // get element that is target of link or url hash
        function getSource(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector('[id="' + id + '"]');
            if (!target)
                return;

            // if ref or figure, modify target to get expected element
            if (id.indexOf('ref-') === 0)
                target = target.querySelector('p');
            else if (id.indexOf('fig:') === 0)
                target = target.querySelector('figure');

            return target;
        }

        // when prev/next arrow button is clicked
        function onPrevNextClick(link, prevNextLink) {
            if (link && prevNextLink)
                goToElement(prevNextLink, window.innerHeight * 0.5);
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // determine position to place tooltip based on link position in
        // viewport and tooltip size
        function positionTooltip(link, left, top) {
            const tooltipElement = document.getElementById('tooltip');
            if (!tooltipElement)
                return;

            // get convenient vars for position/dimensions of
            // link/tooltip/page/view
            link = getRectInPage(link);
            const tooltip = getRectInPage(tooltipElement);
            const view = getRectInPage();

            // horizontal positioning
            if (left)
                // use explicit value
                left = left;
            else if (link.left + tooltip.width < view.right)
                // fit tooltip to right of link
                left = link.left;
            else if (link.right - tooltip.width > view.left)
                // fit tooltip to left of link
                left = link.right - tooltip.width;
            // center tooltip in view
            else
                left = (view.right - view.left) / 2 - tooltip.width / 2;

            // vertical positioning
            if (top)
                // use explicit value
                top = top;
            else if (link.top - tooltip.height > view.top)
                // fit tooltip above link
                top = link.top - tooltip.height;
            else if (link.bottom + tooltip.height < view.bottom)
                // fit tooltip below link
                top = link.bottom;
            else {
                // center tooltip in view
                top = view.top + view.height / 2 - tooltip.height / 2;
                // nudge off of link to left/right if possible
                if (link.right + tooltip.width < view.right)
                    left = link.right;
                else if (link.left - tooltip.width > view.left)
                    left = link.left - tooltip.width;
            }

            tooltipElement.style.left = left + 'px';
            tooltipElement.style.top = top + 'px';
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get position of element relative to page
        function getRectInPage(element) {
            const rect = getRectInView(element);
            const body = getRectInView(document.body);

            const newRect = {};
            newRect.left = rect.left - body.left;
            newRect.top = rect.top - body.top;
            newRect.right = rect.right - body.left;
            newRect.bottom = rect.bottom - body.top;
            newRect.width = rect.width;
            newRect.height = rect.height;

            return newRect;
        }

        // (for interaction with accordion plugin)
        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // (for interaction with accordion plugin)
        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // (for interaction with accordion plugin)
        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- caret left icon -->

<template class="icon_caret_left">
    <!-- modified from: https://fontawesome.com/icons/caret-left -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M192 127.338v257.324c0 17.818-21.543 26.741-34.142 14.142L29.196 270.142c-7.81-7.81-7.81-20.474 0-28.284l128.662-128.662c12.599-12.6 34.142-3.676 34.142 14.142z"
        ></path>
    </svg>
</template>

<!-- caret right icon -->

<template class="icon_caret_right">
    <!-- modified from: https://fontawesome.com/icons/caret-right -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M0 384.662V127.338c0-17.818 21.543-26.741 34.142-14.142l128.662 128.662c7.81 7.81 7.81 20.474 0 28.284L34.142 398.804C21.543 411.404 0 402.48 0 384.662z"
        ></path>
    </svg>
</template>
<!-- jump to first plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin adds a button next to each reference entry,
        // figure, and table that jumps the page to the first occurrence of a
        // link to that item in the manuscript.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'jumpToFirst';

        // default plugin options
        const options = {
            // whether to add buttons next to reference entries
            references: 'true',
            // whether to add buttons next to figures
            figures: 'true',
            // whether to add buttons next to tables
            tables: 'true',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            if (options.references !== 'false')
                makeReferenceButtons();
            if (options.figures !== 'false')
                makeFigureButtons();
            if (options.tables !== 'false')
                makeTableButtons();
        }

        // when jump button clicked
        function onButtonClick() {
            const first = getFirstOccurrence(this.dataset.id);
            if (!first)
                return;

            // update url hash so navigating "back" in history will return
            // user to jump button
            window.location.hash = this.dataset.id;
            // scroll to link
            window.setTimeout(function() {
                goToElement(first, window.innerHeight * 0.5);
            }, 0);
        }

        // get first occurence of link to item in document
        function getFirstOccurrence(id) {
            let query = 'a';
            query += '[href="#' + id + '"]';
            // exclude buttons, anchor links, toc links, etc
            query +=
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            return document.querySelector(query);
        }

        // add button next to each reference entry
        function makeReferenceButtons() {
            const references = document.querySelectorAll('div[id^="ref-"]');
            for (const reference of references) {
                // get reference id and element to add button to
                const id = reference.id;
                const container = reference.firstElementChild;
                const first = getFirstOccurrence(id);

                // if can't find link to reference, ignore
                if (!first)
                    continue;

                // make jump button
                let button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this reference in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.innerHTML = button.outerHTML + container.innerHTML;
                button = container.firstElementChild;
                button.addEventListener('click', onButtonClick);
            }
        }

        // add button next to each figure
        function makeFigureButtons() {
            const figures = document.querySelectorAll('[id^="fig:"]');
            for (const figure of figures) {
                // get figure id and element to add button to
                const id = figure.id;
                const container = figure.querySelector('figcaption') || figure;
                const first = getFirstOccurrence(id);

                // if can't find link to figure, ignore
                if (!first)
                    continue;

                // make jump button
                const button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this figure in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.insertBefore(button, container.firstElementChild);
                button.addEventListener('click', onButtonClick);
            }
        }

        // add button next to each figure
        function makeTableButtons() {
            const tables = document.querySelectorAll('[id^="tbl:"]');
            for (const table of tables) {
                // get ref id and element to add button to
                const id = table.id;
                const container = table.querySelector('caption') || table;
                const first = getFirstOccurrence(id);

                // if can't find link to table, ignore
                if (!first)
                    continue;

                // make jump button
                const button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this table in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.insertBefore(button, container.firstElementChild);
                button.addEventListener('click', onButtonClick);
            }
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // (for interaction with accordion plugin)
        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- angle double up icon -->

<template class="icon_angle_double_up">
    <!-- modified from: https://fontawesome.com/icons/angle-double-up -->
    <svg width="16" height="16" viewBox="0 0 320 512">
        <path
            fill="currentColor"
            d="M177 255.7l136 136c9.4 9.4 9.4 24.6 0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9 0L160 351.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9 0L7 425.7c-9.4-9.4-9.4-24.6 0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1zm-34-192L7 199.7c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l96.4-96.4 96.4 96.4c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9l-136-136c-9.2-9.4-24.4-9.4-33.8 0z"
        ></path>
    </svg>
</template>
<!-- link highlight plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when a user hovers or
        // focuses a link, other links that have the same target will be
        // highlighted. It also makes it such that when clicking a link, the
        // target of the link (eg reference, figure, table) is briefly
        // highlighted.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'linkHighlight';

        // default plugin options
        const options = {
            // whether to also highlight links that go to external urls
            externalLinks: 'false',
            // whether user must click off to unhighlight instead of just
            // un-hovering
            clickUnhighlight: 'false',
            // whether to also highlight links that are unique
            highlightUnique: 'true',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            const links = getLinks();
            for (const link of links) {
                // attach mouse and focus listeners to link
                link.addEventListener('mouseenter', onLinkFocus);
                link.addEventListener('focus', onLinkFocus);
                link.addEventListener('mouseleave', onLinkUnhover);
            }

            // attach click and hash change listeners to window
            window.addEventListener('click', onClick);
            window.addEventListener('touchstart', onClick);
            window.addEventListener('hashchange', onHashChange);

            // run hash change on window load in case user has navigated
            // directly to hash
            onHashChange();
        }

        // when link is focused (tabbed to) or hovered
        function onLinkFocus() {
            highlight(this);
        }

        // when link is unhovered
        function onLinkUnhover() {
            if (options.clickUnhighlight !== 'true')
                unhighlightAll();
        }

        // when the mouse is clicked anywhere in window
        function onClick(event) {
            unhighlightAll();
        }

        // when hash (eg manuscript.html#introduction) changes
        function onHashChange() {
            const target = getHashTarget();
            if (target)
                glowElement(target);
        }

        // get element that is target of link or url hash
        function getHashTarget(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector('[id="' + id + '"]');
            if (!target)
                return;

            return target;
        }

        // start glow sequence on an element
        function glowElement(element) {
            const startGlow = function() {
                onGlowEnd();
                element.dataset.glow = 'true';
                element.addEventListener('animationend', onGlowEnd);
            };
            const onGlowEnd = function() {
                element.removeAttribute('data-glow');
                element.removeEventListener('animationend', onGlowEnd);
            };
            startGlow();
        }

        // highlight link and all others with same target
        function highlight(link) {
            // force unhighlight all to start fresh
            unhighlightAll();

            // get links with same target
            if (!link)
                return;
            const sameLinks = getSameLinks(link);

            // if link unique and option is off, exit and don't highlight
            if (sameLinks.length <= 1 && options.highlightUnique !== 'true')
                return;

            // highlight all same links, and "select" (special highlight) this
            // one
            for (const sameLink of sameLinks) {
                if (sameLink === link)
                    sameLink.setAttribute('data-selected', 'true');
                else
                    sameLink.setAttribute('data-highlighted', 'true');
            }
        }

        // unhighlight all links
        function unhighlightAll() {
            const links = getLinks();
            for (const link of links) {
                link.setAttribute('data-selected', 'false');
                link.setAttribute('data-highlighted', 'false');
            }
        }

        // get links with same target
        function getSameLinks(link) {
            const results = [];
            const links = getLinks();
            for (const otherLink of links) {
                if (
                    otherLink.getAttribute('href') === link.getAttribute('href')
                )
                    results.push(otherLink);
            }
            return results;
        }

        // get all links of types we wish to handle
        function getLinks() {
            let query = 'a';
            if (options.externalLinks !== 'true')
                query += '[href^="#"]';
            // exclude buttons, anchor links, toc links, etc
            query +=
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            return document.querySelectorAll(query);
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>
<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin provides a "table of contents" (toc) panel on
        // the side of the document that allows the user to conveniently
        // navigate between sections of the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'tableOfContents';

        // default plugin options
        const options = {
            // which types of elements to add links for, in
            // "document.querySelector" format
            typesQuery: 'h1, h2, h3',
            // whether toc starts open. use 'true' or 'false', or 'auto' to
            // use 'true' behavior when screen wide enough and 'false' when not
            startOpen: 'false',
            // whether toc closes when clicking on toc link. use 'true' or
            // 'false', or 'auto' to use 'false' behavior when screen wide
            // enough and 'true' when not
            clickClose: 'auto',
            // if list item is more than this many characters, text will be
            // truncated
            charLimit: '50',
            // whether or not to show bullets next to each toc item
            bullets: 'false',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // make toc panel and populate with entries (links to document
            // sections)
            const panel = makePanel();
            if (!panel)
                return;
            makeEntries(panel);
            // attach panel to document after making entries, so 'toc' heading
            // in panel isn't included in toc
            document.body.insertBefore(panel, document.body.firstChild);

            // initial panel state
            if (
                options.startOpen === 'true' ||
                (options.startOpen === 'auto' && !isSmallScreen())
            )
                openPanel();
            else
                closePanel();

            // attach click, scroll, and hash change listeners to window
            window.addEventListener('click', onClick);
            window.addEventListener('scroll', onScroll);
            window.addEventListener('hashchange', onScroll);
            window.addEventListener('keyup', onKeyUp);
            onScroll();

            // add class to push document body down out of way of toc button
            document.body.classList.add('toc_body_nudge');
        }

        // determine if screen wide enough to fit toc panel
        function isSmallScreen() {
            // in default theme:
            // 816px = 8.5in = width of "page" (<body>) element
            // 260px = min width of toc panel (*2 for both sides of <body>)
            return window.innerWidth < 816 + 260 * 2;
        }

        // when mouse is clicked anywhere in window
        function onClick() {
            if (isSmallScreen())
                closePanel();
        }

        // when window is scrolled or hash changed
        function onScroll() {
            highlightViewed();
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            // close on esc
            if (event.key === 'Escape')
                closePanel();
        }

        // find entry of currently viewed document section in toc and highlight
        function highlightViewed() {
            const firstId = getFirstInView(options.typesQuery);

            // get toc entries (links), unhighlight all, then highlight viewed
            const list = document.getElementById('toc_list');
            if (!firstId || !list)
                return;
            const links = list.querySelectorAll('a');
            for (const link of links)
                link.dataset.viewing = 'false';
            const link = list.querySelector('a[href="#' + firstId + '"]');
            if (!link)
                return;
            link.dataset.viewing = 'true';
        }

        // get first or previous toc listed element in top half of view
        function getFirstInView(query) {
            // get all elements matching query and with id
            const elements = document.querySelectorAll(query);
            const elementsWithIds = [];
            for (const element of elements) {
                if (element.id)
                    elementsWithIds.push(element);
            }


            // get first or previous element in top half of view
            for (let i = 0; i < elementsWithIds.length; i++) {
                const element = elementsWithIds[i];
                const prevElement = elementsWithIds[Math.max(0, i - 1)];
                if (element.getBoundingClientRect().top >= 0) {
                    if (
                        element.getBoundingClientRect().top <
                        window.innerHeight / 2
                    )
                        return element.id;
                    else
                        return prevElement.id;
                }
            }
        }

        // make panel
        function makePanel() {
            // create panel
            const panel = document.createElement('div');
            panel.id = 'toc_panel';
            if (options.bullets === 'true')
                panel.dataset.bullets = 'true';

            // create header
            const header = document.createElement('div');
            header.id = 'toc_header';

            // create toc button
            const button = document.createElement('button');
            button.id = 'toc_button';
            button.innerHTML = document.querySelector('.icon_th_list').innerHTML;
            button.title = 'Table of Contents';
            button.classList.add('icon_button');

            // create header text
            const text = document.createElement('h4');
            text.innerHTML = 'Table of Contents';

            // create container for toc list
            const list = document.createElement('div');
            list.id = 'toc_list';

            // attach click listeners
            panel.addEventListener('click', onPanelClick);
            header.addEventListener('click', onHeaderClick);
            button.addEventListener('click', onButtonClick);

            // attach elements
            header.appendChild(button);
            header.appendChild(text);
            panel.appendChild(header);
            panel.appendChild(list);

            return panel;
        }

        // create toc entries (links) to each element of the specified types
        function makeEntries(panel) {
            const elements = document.querySelectorAll(options.typesQuery);
            for (const element of elements) {
                // do not add link if element doesn't have assigned id
                if (!element.id)
                    continue;

                // create link/list item
                const link = document.createElement('a');
                link.classList.add('toc_link');
                switch (element.tagName.toLowerCase()) {
                    case 'h1':
                        link.dataset.level = '1';
                        break;
                    case 'h2':
                        link.dataset.level = '2';
                        break;
                    case 'h3':
                        link.dataset.level = '3';
                        break;
                    case 'h4':
                        link.dataset.level = '4';
                        break;
                }
                link.title = element.innerText;
                let text = element.innerText;
                if (text.length > options.charLimit)
                    text = text.slice(0, options.charLimit) + '...';
                link.innerHTML = text;
                link.href = '#' + element.id;
                link.addEventListener('click', onLinkClick);

                // attach link
                panel.querySelector('#toc_list').appendChild(link);
            }
        }

        // when panel is clicked
        function onPanelClick(event) {
            // stop click from propagating to window/document and closing panel
            event.stopPropagation();
        }

        // when header itself is clicked
        function onHeaderClick(event) {
            togglePanel();
        }

        // when button is clicked
        function onButtonClick(event) {
            togglePanel();
            // stop header underneath button from also being clicked
            event.stopPropagation();
        }

        // when link is clicked
        function onLinkClick(event) {
            if (
                options.clickClose === 'true' ||
                (options.clickClose === 'auto' && isSmallScreen())
            )
                closePanel();
            else
                openPanel();
        }

        // open panel if closed, close if opened
        function togglePanel() {
            const panel = document.getElementById('toc_panel');
            if (!panel)
                return;

            if (panel.dataset.open === 'true')
                closePanel();
            else
                openPanel();
        }

        // open panel
        function openPanel() {
            const panel = document.getElementById('toc_panel');
            if (panel)
                panel.dataset.open = 'true';
        }

        // close panel
        function closePanel() {
            const panel = document.getElementById('toc_panel');
            if (panel)
                panel.dataset.open = 'false';
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- th list icon -->

<template class="icon_th_list">
    <!-- modified from: https://fontawesome.com/icons/th-list -->
    <svg width="16" height="16" viewBox="0 0 512 512" tabindex="-1">
        <path
            fill="currentColor"
            d="M96 96c0 26.51-21.49 48-48 48S0 122.51 0 96s21.49-48 48-48 48 21.49 48 48zM48 208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm0 160c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm96-236h352c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h352c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h352c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"
            tabindex="-1"
        ></path>
    </svg>
</template>
<!-- lightbox plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when a user clicks on an
        // image, the image fills the screen and the user can pan/drag/zoom
        // the image and navigate between other images in the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'lightbox';

        // default plugin options
        const options = {
            // list of possible zoom/scale factors
            zoomSteps:
                '0.1, 0.25, 0.333333, 0.5, 0.666666, 0.75, 1,' +
                '1.25, 1.5, 1.75, 2, 2.5, 3, 3.5, 4, 5, 6, 7, 8',
            // whether to fit image to view ('fit'), display at 100% and shrink
            // if necessary ('shrink'), or always display at 100% ('100')
            defaultZoom: 'fit',
            // whether to zoom in/out toward center of view ('true') or mouse
            // ('false')
            centerZoom: 'false',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // run through each <img> element
            const imgs = document.querySelectorAll('figure > img');
            let count = 1;
            for (const img of imgs) {
                img.classList.add('lightbox_document_img');
                img.dataset.number = count;
                img.dataset.total = imgs.length;
                img.addEventListener('click', openLightbox);
                count++;
            }

            // attach mouse and key listeners to window
            window.addEventListener('mousemove', onWindowMouseMove);
            window.addEventListener('keyup', onKeyUp);
        }

        // when mouse is moved anywhere in window
        function onWindowMouseMove(event) {
            window.mouseX = event.clientX;
            window.mouseY = event.clientY;
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            switch (event.key) {
                // trigger click of prev button
                case 'ArrowLeft':
                    const prevButton = document.getElementById(
                        'lightbox_prev_button'
                    );
                    if (prevButton)
                        prevButton.click();
                    break;
                // trigger click of next button
                case 'ArrowRight':
                    const nextButton = document.getElementById(
                        'lightbox_next_button'
                    );
                    if (nextButton)
                        nextButton.click();
                    break;
                // close on esc
                case 'Escape':
                    closeLightbox();
                    break;
            }
        }

        // open lightbox
        function openLightbox() {
            const lightbox = makeLightbox(this);
            if (!lightbox)
                return;

            blurBody(lightbox);
            document.body.appendChild(lightbox);
        }

        // make lightbox
        function makeLightbox(img) {
            // delete lightbox if it exists, start fresh
            closeLightbox();

            // create screen overlay containing lightbox
            const overlay = document.createElement('div');
            overlay.id = 'lightbox_overlay';

            // create image info boxes
            const numberInfo = document.createElement('div');
            const zoomInfo = document.createElement('div');
            numberInfo.id = 'lightbox_number_info';
            zoomInfo.id = 'lightbox_zoom_info';

            // create container for image
            const imageContainer = document.createElement('div');
            imageContainer.id = 'lightbox_image_container';
            const lightboxImg = makeLightboxImg(
                img,
                imageContainer,
                numberInfo,
                zoomInfo
            );
            imageContainer.appendChild(lightboxImg);

            // create bottom container for caption and navigation buttons
            const bottomContainer = document.createElement('div');
            bottomContainer.id = 'lightbox_bottom_container';
            const caption = makeCaption(img);
            const prevButton = makePrevButton(img);
            const nextButton = makeNextButton(img);
            bottomContainer.appendChild(prevButton);
            bottomContainer.appendChild(caption);
            bottomContainer.appendChild(nextButton);

            // attach top middle and bottom to overlay
            overlay.appendChild(numberInfo);
            overlay.appendChild(zoomInfo);
            overlay.appendChild(imageContainer);
            overlay.appendChild(bottomContainer);

            return overlay;
        }

        // make <img> object that is intuitively draggable and zoomable
        function makeLightboxImg(
            sourceImg,
            container,
            numberInfoBox,
            zoomInfoBox
        ) {
            // create copy of source <img>
            const img = sourceImg.cloneNode(true);
            img.classList.remove('lightbox_document_img');
            img.removeAttribute('id');
            img.removeAttribute('width');
            img.removeAttribute('height');
            img.style.position = 'unset';
            img.style.margin = '0';
            img.style.padding = '0';
            img.style.width = '';
            img.style.height = '';
            img.style.minWidth = '';
            img.style.minHeight = '';
            img.style.maxWidth = '';
            img.style.maxHeight = '';
            img.id = 'lightbox_img';

            // build sorted list of unique zoomSteps, always including a 100%
            let zoomSteps = [];
            const optionsZooms = options.zoomSteps.split(/[^0-9.]/);
            for (const optionZoom of optionsZooms) {
                const newZoom = parseFloat(optionZoom);
                if (newZoom && !zoomSteps.includes(newZoom))
                    zoomSteps.push(newZoom);
            }
            if (!zoomSteps.includes(1))
                zoomSteps.push(1);
            zoomSteps = zoomSteps.sort(function sortNumber(a, b) {
                return a - b;
            });

            // <img> object property variables
            let zoom = 1;
            let translateX = 0;
            let translateY = 0;
            let clickMouseX = undefined;
            let clickMouseY = undefined;
            let clickTranslateX = undefined;
            let clickTranslateY = undefined;

            updateNumberInfo();

            // update image numbers displayed in info box
            function updateNumberInfo() {
                numberInfoBox.innerHTML =
                    sourceImg.dataset.number + ' of ' + sourceImg.dataset.total;
            }

            // update zoom displayed in info box
            function updateZoomInfo() {
                let zoomInfo = zoom * 100;
                if (!Number.isInteger(zoomInfo))
                    zoomInfo = zoomInfo.toFixed(2);
                zoomInfoBox.innerHTML = zoomInfo + '%';
            }

            // move to closest zoom step above current zoom
            const zoomIn = function() {
                for (const zoomStep of zoomSteps) {
                    if (zoomStep > zoom) {
                        zoom = zoomStep;
                        break;
                    }
                }
                updateTransform();
            };

            // move to closest zoom step above current zoom
            const zoomOut = function() {
                zoomSteps.reverse();
                for (const zoomStep of zoomSteps) {
                    if (zoomStep < zoom) {
                        zoom = zoomStep;
                        break;
                    }
                }
                zoomSteps.reverse();

                updateTransform();
            };

            // update display of <img> based on scale/translate properties
            const updateTransform = function() {
                // set transform
                img.style.transform =
                    'translate(' +
                    (translateX || 0) +
                    'px,' +
                    (translateY || 0) +
                    'px) scale(' +
                    (zoom || 1) +
                    ')';

                // get new width/height after scale
                const rect = img.getBoundingClientRect();
                // limit translate
                translateX = Math.max(translateX, -rect.width / 2);
                translateX = Math.min(translateX, rect.width / 2);
                translateY = Math.max(translateY, -rect.height / 2);
                translateY = Math.min(translateY, rect.height / 2);

                // set transform
                img.style.transform =
                    'translate(' +
                    (translateX || 0) +
                    'px,' +
                    (translateY || 0) +
                    'px) scale(' +
                    (zoom || 1) +
                    ')';

                updateZoomInfo();
            };

            // fit <img> to container
            const fit = function() {
                // no x/y offset, 100% zoom by default
                translateX = 0;
                translateY = 0;
                zoom = 1;

                // widths of <img> and container
                const imgWidth = img.naturalWidth;
                const imgHeight = img.naturalHeight;
                const containerWidth = parseFloat(
                    window.getComputedStyle(container).width
                );
                const containerHeight = parseFloat(
                    window.getComputedStyle(container).height
                );

                // how much zooming is needed to fit <img> to container
                const xRatio = imgWidth / containerWidth;
                const yRatio = imgHeight / containerHeight;
                const maxRatio = Math.max(xRatio, yRatio);
                const newZoom = 1 / maxRatio;

                // fit <img> to container according to option
                if (options.defaultZoom === 'shrink') {
                    if (maxRatio > 1)
                        zoom = newZoom;
                } else if (options.defaultZoom === 'fit')
                    zoom = newZoom;

                updateTransform();
            };

            // when mouse wheel is rolled anywhere in container
            const onContainerWheel = function(event) {
                if (!event)
                    return;

                // let ctrl + mouse wheel to zoom behave as normal
                if (event.ctrlKey)
                    return;

                // prevent normal scroll behavior
                event.preventDefault();
                event.stopPropagation();

                // point around which to scale img
                const viewRect = container.getBoundingClientRect();
                const viewX = (viewRect.left + viewRect.right) / 2;
                const viewY = (viewRect.top + viewRect.bottom) / 2;
                const originX = options.centerZoom === 'true' ? viewX : mouseX;
                const originY = options.centerZoom === 'true' ? viewY : mouseY;

                // get point on image under origin
                const oldRect = img.getBoundingClientRect();
                const oldPercentX = (originX - oldRect.left) / oldRect.width;
                const oldPercentY = (originY - oldRect.top) / oldRect.height;

                // increment/decrement zoom
                if (event.deltaY < 0)
                    zoomIn();
                if (event.deltaY > 0)
                    zoomOut();

                // get offset between previous image point and origin
                const newRect = img.getBoundingClientRect();
                const offsetX =
                    originX - (newRect.left + newRect.width * oldPercentX);
                const offsetY =
                    originY - (newRect.top + newRect.height * oldPercentY);

                // translate image to keep image point under origin
                translateX += offsetX;
                translateY += offsetY;

                // perform translate
                updateTransform();
            };

            // when container is clicked
            function onContainerClick(event) {
                // if container itself is target of click, and not other
                // element above it
                if (event.target === this)
                    closeLightbox();
            }

            // when mouse button is pressed on image
            const onImageMouseDown = function(event) {
                // store original mouse position relative to image
                clickMouseX = window.mouseX;
                clickMouseY = window.mouseY;
                clickTranslateX = translateX;
                clickTranslateY = translateY;
                event.stopPropagation();
                event.preventDefault();
            };

            // when mouse button is released anywhere in window
            const onWindowMouseUp = function(event) {
                // reset original mouse position
                clickMouseX = undefined;
                clickMouseY = undefined;
                clickTranslateX = undefined;
                clickTranslateY = undefined;

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('mouseup', onWindowMouseUp);
            };

            // when mouse is moved anywhere in window
            const onWindowMouseMove = function(event) {
                if (
                    clickMouseX === undefined ||
                    clickMouseY === undefined ||
                    clickTranslateX === undefined ||
                    clickTranslateY === undefined
                )
                    return;

                // offset image based on original and current mouse position
                translateX = clickTranslateX + window.mouseX - clickMouseX;
                translateY = clickTranslateY + window.mouseY - clickMouseY;
                updateTransform();
                event.preventDefault();

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('mousemove', onWindowMouseMove);
            };

            // when window is resized
            const onWindowResize = function(event) {
                fit();

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('resize', onWindowResize);
            };

            // attach the necessary event listeners
            img.addEventListener('dblclick', fit);
            img.addEventListener('mousedown', onImageMouseDown);
            container.addEventListener('wheel', onContainerWheel);
            container.addEventListener('mousedown', onContainerClick);
            container.addEventListener('touchstart', onContainerClick);
            window.addEventListener('mouseup', onWindowMouseUp);
            window.addEventListener('mousemove', onWindowMouseMove);
            window.addEventListener('resize', onWindowResize);

            // run fit() after lightbox atttached to document and <img> Loaded
            // so needed container and img dimensions available
            img.addEventListener('load', fit);

            return img;
        }

        // make caption
        function makeCaption(img) {
            const caption = document.createElement('div');
            caption.id = 'lightbox_caption';
            const captionSource = img.nextElementSibling;
            if (captionSource.tagName.toLowerCase() === 'figcaption') {
                const captionCopy = makeCopy(captionSource);
                caption.innerHTML = captionCopy.innerHTML;
            }

            caption.addEventListener('touchstart', function(event) {
                event.stopPropagation();
            });

            return caption;
        }

        // make carbon copy of html dom element
        function makeCopy(source) {
            const sourceCopy = source.cloneNode(true);

            // delete elements marked with ignore (eg anchor and jump buttons)
            const deleteFromCopy = sourceCopy.querySelectorAll(
                '[data-ignore="true"]'
            );
            for (const element of deleteFromCopy)
                element.remove();

            // delete certain element attributes
            const attributes = [
                'id',
                'data-collapsed',
                'data-selected',
                'data-highlighted',
                'data-glow'
            ];
            for (const attribute of attributes) {
                sourceCopy.removeAttribute(attribute);
                const elements = sourceCopy.querySelectorAll(
                    '[' + attribute + ']'
                );
                for (const element of elements)
                    element.removeAttribute(attribute);
            }

            return sourceCopy;
        }

        // make button to jump to previous image in document
        function makePrevButton(img) {
            const prevButton = document.createElement('button');
            prevButton.id = 'lightbox_prev_button';
            prevButton.title = 'Jump to the previous image in the document [←]';
            prevButton.classList.add('icon_button', 'lightbox_button');
            prevButton.innerHTML = document.querySelector(
                '.icon_caret_left'
            ).innerHTML;

            // attach click listeners to button
            prevButton.addEventListener('click', function() {
                getPrevImg(img).click();
            });

            return prevButton;
        }

        // make button to jump to next image in document
        function makeNextButton(img) {
            const nextButton = document.createElement('button');
            nextButton.id = 'lightbox_next_button';
            nextButton.title = 'Jump to the next image in the document [→]';
            nextButton.classList.add('icon_button', 'lightbox_button');
            nextButton.innerHTML = document.querySelector(
                '.icon_caret_right'
            ).innerHTML;

            // attach click listeners to button
            nextButton.addEventListener('click', function() {
                getNextImg(img).click();
            });

            return nextButton;
        }

        // get previous image in document
        function getPrevImg(img) {
            const imgs = document.querySelectorAll('.lightbox_document_img');

            // find index of provided img
            let index;
            for (index = 0; index < imgs.length; index++) {
                if (imgs[index] === img)
                    break;
            }


            // wrap index to other side if < 1
            if (index - 1 >= 0)
                index--;
            else
                index = imgs.length - 1;
            return imgs[index];
        }

        // get next image in document
        function getNextImg(img) {
            const imgs = document.querySelectorAll('.lightbox_document_img');

            // find index of provided img
            let index;
            for (index = 0; index < imgs.length; index++) {
                if (imgs[index] === img)
                    break;
            }


            // wrap index to other side if > total
            if (index + 1 <= imgs.length - 1)
                index++;
            else
                index = 0;
            return imgs[index];
        }

        // close lightbox
        function closeLightbox() {
            focusBody();

            const lightbox = document.getElementById('lightbox_overlay');
            if (lightbox)
                lightbox.remove();
        }

        // make all elements behind lightbox non-focusable
        function blurBody(overlay) {
            const all = document.querySelectorAll('*');
            for (const element of all)
                element.tabIndex = -1;
            document.body.classList.add('body_no_scroll');
        }

        // make all elements focusable again
        function focusBody() {
            const all = document.querySelectorAll('*');
            for (const element of all)
                element.removeAttribute('tabIndex');
            document.body.classList.remove('body_no_scroll');
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- caret left icon -->

<template class="icon_caret_left">
    <!-- modified from: https://fontawesome.com/icons/caret-left -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M192 127.338v257.324c0 17.818-21.543 26.741-34.142 14.142L29.196 270.142c-7.81-7.81-7.81-20.474 0-28.284l128.662-128.662c12.599-12.6 34.142-3.676 34.142 14.142z"
        ></path>
    </svg>
</template>

<!-- caret right icon -->

<template class="icon_caret_right">
    <!-- modified from: https://fontawesome.com/icons/caret-right -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M0 384.662V127.338c0-17.818 21.543-26.741 34.142-14.142l128.662 128.662c7.81 7.81 7.81 20.474 0 28.284L34.142 398.804C21.543 411.404 0 402.48 0 384.662z"
        ></path>
    </svg>
</template>
<!-- attributes plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin allows arbitrary HTML attributes to be attached
        // to (almost) any element. Place an HTML comment inside or next to the
        // desired element in the format <!-- $attribute="value" -->

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'attributes';

        // default plugin options
        const options = {
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // get list of comments in document
            const comments = findComments();

            for(const comment of comments)
                if (comment.parentElement)
                    addAttributes(
                        comment.parentElement,
                        comment.nodeValue.trim()
                    );
        }

        // add html attributes to specified element based on string of 
        // html attributes and values
        function addAttributes(element, text) {
            // regex's for finding attribute/value pairs in the format of
            // attribute="value" or attribute='value
            const regex2 = /\$([a-zA-Z\-]+)?=\"(.+?)\"/;
            const regex1 = /\$([a-zA-Z\-]+)?=\'(.+?)\'/;

            // loop through attribute/value pairs
            let match;
            while(match = text.match(regex2) || text.match(regex1)) {
                // get attribute and value from regex capture groups
                let attribute = match[1];
                let value = match[2];

                // remove from string
                text = text.substring(match.index + match[0].length);

                if (!attribute || !value)
                    break;

                // set attribute of parent element
                try {
                    element.setAttribute(attribute, value);
                } catch(error) {
                    console.log(error);
                }

                // special case for colspan
                if (attribute === 'colspan')
                    removeTableCells(element, value);
            }
        }

        // get list of comment elements in document
        function findComments() {
            const comments = [];

            // iterate over comment nodes in document
            function acceptNode(node) {
                return NodeFilter.FILTER_ACCEPT;
            }
            const iterator = document.createNodeIterator(
                document.body,
                NodeFilter.SHOW_COMMENT,
                acceptNode
            );
            let node;
            while(node = iterator.nextNode())
                comments.push(node);

            return comments;
        }

        // remove certain number of cells after specified cell
        function removeTableCells(cell, number) {
            number = parseInt(number);
            if (!number)
                return;

            // remove elements
            for(; number > 1; number--) {
                if (cell.nextElementSibling)
                    cell.nextElementSibling.remove();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>
<!-- mathjax plugin configuration -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        "CommonHTML": { linebreaks: { automatic: true } },
        "HTML-CSS": { linebreaks: { automatic: true } },
        "SVG": { linebreaks: { automatic: true } },
        "fast-preview": { disabled: true }
  });
</script>

<!-- mathjax plugin -->

<script
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"
    integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A=="
    crossorigin="anonymous"
>
    // /////////////////////////
    // DESCRIPTION
    // /////////////////////////

    // This third-party plugin 'MathJax' allows the proper rendering of
    // math/equations written in LaTeX.

    // https://www.mathjax.org/
</script>
<!-- annotations plugin -->

<script>
    // /////////////////////////
    // DESCRIPTION
    // /////////////////////////

    // This third-party plugin 'Hypothesis' allows public annotation of the
    // manuscript.

    // https://web.hypothes.is/

    // plugin configuration
    window.hypothesisConfig = function() {
        return {
            branding: {
                accentColor: '#2196f3',
                appBackgroundColor: '#f8f8f8',
                ctaBackgroundColor: '#f8f8f8',
                ctaTextColor: '#000000',
                selectionFontFamily: 'Open Sans, Helvetica, sans serif',
                annotationFontFamily: 'Open Sans, Helvetica, sans serif'
            }
        };
    };

    // hypothesis client script
    const embed = 'https://hypothes.is/embed.js';
    // hypothesis annotation count query url
    const query = 'https://api.hypothes.is/api/search?limit=0&url='

    
    // start script
    function start() {
        const button = makeButton();
        document.body.insertBefore(button, document.body.firstChild);
        insertCount(button);
    }

    // make button
    function makeButton() {
        // create button
        const button = document.createElement('button');
        button.id = 'hypothesis_button';
        button.innerHTML = document.querySelector('.icon_hypothesis').innerHTML;
        button.title = 'Hypothesis annotations';
        button.classList.add('icon_button');

        function onClick(event) {
            onButtonClick(event, button);
        }

        // attach click listeners
        button.addEventListener('click', onClick);

        return button;
    }

    // insert annotations count
    async function insertCount(button) {
        // get annotation count from Hypothesis based on url
        let count = '-';
        try {
            const canonical = document.querySelector('link[rel="canonical"]');
            const location = window.location;
            const url = encodeURIComponent((canonical || location).href);
            const response = await fetch(query + url);
            const json = await response.json();
            count = json.total || '-';
        } catch(error) {
            console.log(error);
        }
        
        // put count into button
        const counter = document.createElement('span');
        counter.id = 'hypothesis_count';
        counter.innerHTML = count;
        button.title = 'View ' + count + ' Hypothesis annotations';
        button.append(counter);
    }

    // when button is clicked
    function onButtonClick(event, button) {
        const script = document.createElement('script');
        script.src = embed;
        document.body.append(script);
        button.remove();
    }

    window.addEventListener('load', start);
</script>

<!-- hypothesis icon -->

<template class="icon_hypothesis">
    <!-- modified from: https://simpleicons.org/icons/hypothesis.svg / https://git.io/Jf1VB -->
    <svg width="16" height="16" viewBox="0 0 24 24" tabindex="-1">
        <path
            fill="currentColor"
            d="M3.43 0C2.5 0 1.72 .768 1.72 1.72V18.86C1.72 19.8 2.5 20.57 3.43 20.57H9.38L12 24L14.62 20.57H20.57C21.5 20.57 22.29 19.8 22.29 18.86V1.72C22.29 .77 21.5 0 20.57 0H3.43M5.14 3.43H7.72V9.43S8.58 7.72 10.28 7.72C12 7.72 13.74 8.57 13.74 11.24V17.14H11.16V12C11.16 10.61 10.28 10.07 9.43 10.29C8.57 10.5 7.72 11.41 7.72 13.29V17.14H5.14V3.43M18 13.72C18.95 13.72 19.72 14.5 19.72 15.42A1.71 1.71 0 0 1 18 17.13A1.71 1.71 0 0 1 16.29 15.42C16.29 14.5 17.05 13.71 18 13.71Z"
            tabindex="-1"
        ></path>
    </svg>
</template>
<!-- analytics plugin -->

<!-- copy and paste code from Google Analytics or similar service here -->
</body>
</html>
